## 一、词法作用域与动态作用域

### 1.1 JavaScript 使用词法作用域（静态作用域）

> 其他语言比如bash就使用的是动态作用域；

- 词法作用域决定于 **函数定义时** 所处的环境，而不是调用位置

```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();
```

**结果是：** `1`

### 1.2 动态作用域

在动态作用域中：函数内部的变量查找，是从 **调用它的位置** 开始向上查找。

假如 JavaScript 是动态作用域，上面的例子结果会是`2`

再来两个《JavaScript 权威指南》的经典例子：

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
console.log(checkscope()); 
// 词法作用域：结果local scope
// 动态作用域：结果local scope
```

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
console.log(checkscope()());
// 词法作用域：结果local scope
// 动态作用域：结果global scope
```

> checkscope 返回了函数 f ，即使稍后执行 f，它依然保留对 checkscope 内部作用域的引用，这就是 **闭包**

### 二、作用域链

在 JavaScript 中：函数执行时，会创建一个作用域链，用于查找变量。

查找顺序：

- 当前函数内部
- **函数定义时**的外层作用域
- 一直向上，直到全局作用域

---
### 三、闭包

闭包定义：函数被返回/传递后仍然可访问其定义时的外部变量。

例1：

```js
function outer() {
  let x = 1;
  return function inner() {
    console.log(x);
  };
}
const fn = outer();
fn(); // 1
```

解释：（ECMAScript® 2023 Language Specification § 9.1.2 Lexical Environments英文原文翻译）**即使创建词法环境的执行上下文不再活跃，外层引用仍然可能被保留**。

再改一改，闭包+作用域链版本：

```js
function outerMax(){
    let x = 1;
    return function outer() {
        let x = 2; // 若注释这里 则输出1
        return function inner() {
            console.log(x); // 2
        };
    }
}
const fn = outerMax()(); 
fn(); 
```

例2：

```js
// 版本1
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0](); // 3
data[1](); // 3
data[2](); // 3

// 版本2.1
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
        return function(){
            console.log(i);
        }
  })(i);
}

data[0](); // 0
data[1](); // 1
data[2](); // 2

// 版本2.2
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function () {
        return function(){
            console.log(i);
        }
  })();
}

data[0](); // 3
data[1](); // 3
data[2](); // 3

// 版本3
var data = [];

for (let i = 0; i < 3; i++) {
  data[i] = function() {
    console.log(i);
  };
}

data[0](); // 0
data[1](); // 1
data[2](); // 2
```

- 版本1：使用 **var** 时，所有闭包共享同一个外层变量；
- 版本2.1：立即执行函数表达式，每次 `(function(i){ ... })(i)` 创建了一个新的执行上下文，每个新的执行上下文独立存储一个i；
- 版本2.2：立即执行函数表达式，每次 `(function(){ ... })()` 创建了一个新的执行上下文，但是在每个新创建的执行上下文并没有找到i，所以还是得沿着作用域链向外层共享的i查找；
- 版本3：`let` 声明会在每次循环迭代时创建一个新的块级作用

参考文献：
- https://github.com/mqyqingfeng/Blog/issues/9
