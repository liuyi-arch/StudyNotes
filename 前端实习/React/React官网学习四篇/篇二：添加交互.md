### 1. 响应事件

- 添加事件处理函数：

  - `<button onclick = {handleClick}>`与`<button onClick = {handleClick()}>`前者在每次点击时触发，后者会在渲染时，即使没有点击也会触发。
  - 事件处理函数通常以`handle + 事件名`命名，事件处理函数prop通常以`on + 事件名`命名。

- 事件冒泡、阻止事件冒泡：

  - 什么是事件冒泡？

    - 如果把组件抽象为树结构，即根组件为树根，最内层子组件为叶子节点。若某个事件触发，它将从触发处出发，逐层向叶子节点方向冒泡。

  - 如何阻止事件冒泡？

    - 使用`e.stopPropagation()`：

      ```jsx
      // 会发生事件冒泡
      export default function Toolbar() {
        return (
          <div className="Toolbar" onClick={() => {
            alert('你点击了 toolbar ！');
          }}>
            <button onClick={() => alert('正在播放！')}>
              播放电影
            </button>
            <button onClick={() => alert('正在上传！')}>
              上传图片
            </button>
          </div>
        );
      }
      
      // 不会发生事件冒泡
      function Button({ onClick, children }) {
        return (
          <button onClick={e => {
            e.stopPropagation();
            onClick();
          }}>
            {children}
          </button>
        );
      }
      
      export default function Toolbar() {
        return (
          <div className="Toolbar" onClick={() => {
            alert('你点击了 toolbar ！');
          }}>
            <Button onClick={() => alert('正在播放！')}>
              播放电影
            </Button>
            <Button onClick={() => alert('正在上传！')}>
              上传图片
            </Button>
          </div>
        );
      }
      ```

- 什么是默认行为，如何阻止？

  - 举个例子，点击`<form>`表单按钮会触发表单提交事件，同时，将触发页面重新加载这个默认行为。

  - 可以使用`e.preventDefault()`解决：

    ```jsx
    // 原始伴随默认行为
    export default function Signup() {
      return (
        <form onSubmit={() => alert('提交表单！')}>
          <input />
          <button>发送</button>
        </form>
      );
    }
    
    // 阻止默认行为
    export default function Signup() {
      return (
        <form onSubmit={e => {
          e.preventDefault();
          alert('提交表单！');
        }}>
          <input />
          <button>发送</button>
        </form>
      );
    }
    ```

- 可以在事件处理函数中执行副作用。

> 第二个挑战。

### 2. State：组件的记忆

- 普通局部变量无法在多次渲染中持久保存，更改局部变量不会触发渲染：

  ```jsx
  import { sculptureList } from './data.js';
  
  export default function Gallery() {
    let index = 0;
  
    function handleClick() {
      index = index + 1;
    }
  
    let sculpture = sculptureList[index];
    return (
      <>
        <button onClick={handleClick}>
          Next
        </button>
        <h2>
          <i>{sculpture.name} </i> 
          by {sculpture.artist}
        </h2>
        <h3>  
          ({index + 1} of {sculptureList.length})
        </h3>
        <img 
          src={sculpture.url} 
          alt={sculpture.alt}
        />
        <p>
          {sculpture.description}
        </p>
      </>
    );
  }
  ```

  - 可以采用state变量实现：

    ```jsx
    // 第一步
    import { useState } from 'react';
    
    // 第二步：下面这行替换let index = 0;
    const [index, setIndex] = useState(0);
    
    // 第三步：handleClick函数如下更改
    function handleClick() {
      setIndex(index + 1);
    }
    ```

  - ⚠️注意，多次渲染才使用state变量，单次渲染，使用普通变量即可（见第四个挑战）。

- 关于useState：

  - React中，以use开头的函数都为Hooks，一般对返回值命名为`const [thing, setThing]`；

  - state用于保存上次渲染值，setState用于更改state值并触发React渲染组件，useState(0)表示设置state初始值为0；

  - Hooks只能在组件最顶层调用，不能在条件语句、循环语句或其他嵌套函数中调用Hooks；

  - 对于同时更改的state变量如何合并为同一个？

    ```jsx
    // 第一步：将两个独立的state变量由包含它们的单个对象替换
    // 原始代码:
    // const [index, setIndex] = useState(0);
    // const [showMore, setShowMore] = useState(false);
    
    // 合并后代码:
    const [galleryState, setGalleryState] = useState({
      index: 0,
      showMore: false
    });
    
    
    // 第二步：从galleryState对象中解构两个state变量
    // 添加解构代码
    const { index, showMore } = galleryState;
    
    
    // 第三步：更新setState函数，使用展开运算符保留不想更改属性
    // 原有代码：
    // function handleNextClick(){
    //   setIndex(index + 1);
    // }
    
    // function handleMoreClick(){
    //   setShowMore(!showMore);
    // }
    
    // 合并后代码：
    function handleNextClick() {
      setGalleryState({
        ...galleryState, // 保留现有的 showMore 值
        index: galleryState.index + 1 // 更新 index
      });
    }
    
    function handleMoreClick() {
      setGalleryState({
        ...galleryState, // 保留现有的 index 值
        showMore: !galleryState.showMore // 切换 showMore
      });
    }
    ```

  - React中state以哪种数据结构存储？同一个组件不同实例的state可以共享吗？父组件是否可以更改子组件state？

    - React中每个组件**实例**都有一个数组，用于保存state，按照顶层调用的顺序按索引顺序排列；
    - 同一组件不同实例state是隔离且私有的；
    - 父组件无法更改子组件的state。

> 第一个、第四个挑战。

### 3. 渲染和提交

- 什么时候触发渲染？

  - 组件初次渲染；

    - 初次渲染，通过调用createRoot方法获取根节点，然后通过render函数完成：

      ```jsx
      import { createRoot } from 'react-dom/client';
      
      const root = createRoot(document.getElementById('root'))
      root.render();
      ```

    - 初次渲染，通过appendChild()建立DOM节点。重渲染通过diff算法执行最小更改。

  - 组件或祖先组件状态发生改变。

### 4. state 如同一张快照

- React会等到事件处理函数中语句全部执行完毕再处理state更新，即执行setState不会立即修改state变量：

  ```jsx
  // 示例一：点击弹出0，而不是5
  import { useState } from 'react';
  
  export default function Counter() {
    const [number, setNumber] = useState(0);
  
    return (
      <>
        <h1>{number}</h1>
        <button onClick={() => {
          setNumber(number + 5);
          alert(number);
          // 即使设置定时器延迟弹窗，仍然弹出0
          // setTimeout(() => {
          //   alert(number);
          // }, 3000);
        }}>+5</button>
      </>
    )
  }
  
  // 示例二：调用3次setNumber，每次点击只让number递增一次
  import { useState } from 'react';
  
  export default function Counter() {
    const [number, setNumber] = useState(0);
  
    return (
      <>
        <h1>{number}</h1>
        <button onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}>+3</button>
      </>
    )
  }
  ```

  - 为什么要批处理事件处理函数中所有代码再执行state更改呢？
    - 因为若同时更新多个state变量，不会更新一个触发一次渲染。

### 5. 把一系列 state 更新加入队列

- 如何解决不同时更新同一个state问题？

  - 使用函数式更新：

    ```jsx
    <button onClick={() => {
      setNumber(n => n + 1);
    	setNumber(n => n + 1);
      setNumber(n => n + 1);
    }}>+5</button>
    ```

    - 再来几个示例：

      ```jsx
      // 显示6
      <button onClick={() => {
        setNumber(number + 5);
        setNumber(n => n + 1);
      }}>
      ```

      ```jsx
      // 显示42
      <button onClick={() => {
        setNumber(number + 5);
        setNumber(n => n + 1);
        setNumber(42);
      }}>
      ```

  - 使用useEffect。

- 通常以state变量的第一个字母来命名更新函数的参数：

  ```jsx
  setEnabled(e => !e);
  setLastName(ln => ln.reverse());
  setFriendCount(fc => fc * 2);
  ```

- 挑战1，使用async/await延迟多次渲染：

  ```jsx
  import { useState } from 'react';
  
  export default function Counter() {
      const [number, setNumber] = useState(0);
  
      async function handleClick() {
          setNumber(n => n + 1);
          await delay(3000);
          setNumber(n => n + 1);
          await delay(3000);
          setNumber(n => n + 1);
      }
  
      return (
          <>
              <h1>{number}</h1>
              <button onClick={handleClick}>+3</button>
          </>
      )
  
      function delay(ms) {
          return new Promise(resolve => {
              setTimeout(resolve, ms);
          });
      }
  }
  ```

### 6. 更新 state 中的对象

- state中存放的数字、字符串、布尔值等是不可变的（immutation），即只能通过setState触发重新渲染更改值；而对象严格来说是可变的（mutation），即可直接修改对象自身内容，如：

  ```jsx
  const [position, setPosition] = useState({ x: 0, y: 0 });
  position.x = 5;
  ```

  - 但我们应该将所有存放在state中数据类型都视为只可读，包括对象：
    - 这是因为即使对象可直接修改自身内容，但没有使用setState函数，React不知道对象已更改。

- 对于包含多个键值对的对象，如果我们只想更改其中一个键值对，其余保持不变，可以使用展开运算符来复制对象：

  ```jsx
  setPerson({
    ...person, // 复制上一个 person 中的所有字段
    firstName: e.target.value // 只更改firstName这个键值对
  });
  ```

- 使用`[]`来实现属性的动态命名：

  ```jsx
  // 原始代码
  function handleFirstNameChange(e) {
      setPerson({
          ...person,
          firstName: e.target.value
      });
  }
  
  function handleLastNameChange(e) {
      setPerson({
          ...person,
          lastName: e.target.value
      });
  }
  
  function handleEmailChange(e) {
      setPerson({
          ...person,
          email: e.target.value
      });
  }
  
  // 使用[]实现属性的动态命名
  function handleChange(e) {
      setPerson({
          ...person,
          [e.target.name]: e.target.value // e.target.name即input元素的name属性
      });
  }
  ```

- （简化代码）使用Immer无需拷贝对象，直接修改需要更改的那个键值对：

  ```jsx
  // 使用
  // 1. 下载依赖：npm install use-immer
  // 2. import { useImmer } from 'use-immer' 替换掉 import { useState } from 'react'
  
  const [person, updatePerson] = useImmer({
      name: 'Niki de Saint Phalle',
      artwork: {
          title: 'Blue Nana',
          city: 'Hamburg',
          image: 'https://i.imgur.com/Sd1AgUOm.jpg',
      }
  });
  // 原始修改title属性
  function handleTitleChange(e) {
      setPerson({
          ...person,
          artwork: {
              ...person.artwork,
              title: e.target.value
          }
      });
  }
  
  // Immer直接修改title属性
  function handleTitleChange(e) {
      updatePerson(draft => {
          draft.artwork.title = e.target.value;
      });
  }
  ```

> 再做一做挑战。

### 7. 更新 state 中的数组

- 推荐使用能返回新数组的数组方法，而不是会修改数组的数组方法：

  |          | 避免使用 (会改变原始数组)     | 推荐使用 (会返回一个新数组）                                 |
  | -------- | ----------------------------- | ------------------------------------------------------------ |
  | 添加元素 | `push`，`unshift`             | `concat`，`[...arr]` 展开语法（[例子](https://zh-hans.react.dev/learn/updating-arrays-in-state#adding-to-an-array)） |
  | 删除元素 | `pop`，`shift`，`splice`      | `filter`，`slice`（[例子](https://zh-hans.react.dev/learn/updating-arrays-in-state#removing-from-an-array)） |
  | 替换元素 | `splice`，`arr[i] = ...` 赋值 | `map`（[例子](https://zh-hans.react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array)） |
  | 排序     | `reverse`，`sort`             | 先将数组复制一份（[例子](https://zh-hans.react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array)） |

> React中使用数组方法增删改查需要练习，完成挑战部分。
