## 遍历方式

> 参考：
>
> - https://www.cnblogs.com/houxianzhou/p/18748363
> - forEach弊端：https://cloud.tencent.com/developer/article/2470587
> - 对象静态方法：https://juejin.cn/post/7129374520015585317
> - `for (const [i, v] of arr.entries())`解决for...of索引问题：https://blog.fundebug.com/2019/03/11/4-ways-to-loop-array-inj-javascript/

### 1. for...in与for...of

| 特性                     | `for...in`                             | `for...of`                                                   |
| ------------------------ | -------------------------------------- | ------------------------------------------------------------ |
| **遍历对象类型**         | 遍历对象的**可枚举属性键（key）**      | 遍历**可迭代对象的值（value）**                              |
| **适用对象**             | 普通对象（Object）                     | 可迭代对象（Array、String、Set、Map、arguments、NodeList等） |
| **是否可用于数组**       | 不推荐（无序、额外属性、性能低）       | 推荐（按索引顺序遍历值）                                     |
| **遍历结果**             | 属性名（key）                          | 元素值（value）                                              |
| **是否遍历原型链属性**   | ✅ 是（可通过 `hasOwnProperty()` 过滤） | ❌ 否                                                         |
| **是否跳过空元素**       | ✅ 是（跳过稀疏数组中的空位）           | ❌ 否                                                         |
| **是否遍历 Symbol 属性** | ❌ 否                                   | ❌ 否（但对象自定义迭代器可实现）                             |
| **遍历顺序**             | 无序（由引擎实现）                     | 有序（按照迭代顺序）                                         |
| **能否拿到索引**         | key 就是索引（字符串类型）             | 需配合 `arr.entries()` 拿到索引和值                          |
| **性能表现**             | 慢（遍历属性）                         | 快（原生迭代器）                                             |

- for...in为什么不适合遍历数组？
  - 因为for...in无序、会跳过空元素、会遍历原型链上属性。
    - 但可通过obj.hasOwnProperty(key)判断是否是自身属性，从而在循环内部过滤原型链上属性。

- for...of有什么弊端？
  - 没有索引，可以通过for(const [index, item] in arr.entries())解决。
- for...in与for...of使用场景？
  - for...in：用于遍历普通对象的键，不推荐遍历数组**，**不能遍历 Map/Set、Symbol 类型等。
  - for...of：用于遍历可迭代对象的值，比如数组、字符串、Map、Set，不能遍历普通对象、WeakMap/WeakSet、Symbol类型等。

### 2. forEach与map

| 特性                               | `forEach()`                                                 | `map()`                                  |
| ---------------------------------- | ----------------------------------------------------------- | ---------------------------------------- |
| **返回值**                         | 没有返回值（返回 `undefined`）                              | 返回一个**新数组**                       |
| **是否改变原数组**                 | 不返回新数组，但可以**修改原数组内容**（通过 `arr[index]`） | 不会修改原数组                           |
| **适用场景**                       | 执行副作用（如打印、修改外部变量）                          | 映射转换生成新数组                       |
| **是否可链式调用**                 | ❌ 不可链式调用（无返回值）                                  | ✅ 可链式调用                             |
| **是否跳过空元素**                 | ✅ 会跳过稀疏数组中的空位                                    | ✅ 同样跳过空位                           |
| **是否支持中断（break/continue）** | ❌ 不支持（只能通过 `throw` 中断）                           | ❌ 不支持                                 |
| **是否可处理异步函数**             | ❌ 不等待异步回调执行                                        | ❌ 同样不等待异步执行（返回的是同步结果） |
| **性能**                           | 相对较低（每次循环新建回调函数上下文）                      | 稍优（但仍比 `for...of` 慢）             |
| **修改元素**                       | 修改 `item` 无效（形参副本）；修改 `arr[index]` 有效        | 返回新数组，不改原数组                   |
| **典型用途**                       | 输出、日志、DOM 操作、副作用                                | 数据映射、生成新结果数组                 |

- forEach与map异同？使用场景？
  - 相同：
    - 均跳过空元素、不支持中断、不可处理异步函数、不修改原数组等。
    - 第一个参数为函数，该函数传入参数依次为item、index、arr。
  - 不同：
    - 返回值、链式调用等。
  - forEach常用于输出日志、副作用，map常用于生成新结果数组。
- 关于是否修改原数组？
  - 对回调函数中第一个形参item修改不改变原数组，因为形参是对原数组元素的值拷贝。
  - 可通过arr[index]直接对数组元素的引用修改，进而改变原数组。

### 3. 其他数组遍历方法

| 方法           | 返回值                               | 是否修改原数组 | 典型用途                     | 可否中途终止                 | 备注                                                |
| -------------- | ------------------------------------ | -------------- | ---------------------------- | ---------------------------- | --------------------------------------------------- |
| **`filter()`** | 返回一个由符合条件的元素组成的新数组 | ❌ 否           | 过滤数据                     | ❌ 否                         | 不改变原数组；返回长度 ≤ 原数组                     |
| **`some()`**   | 布尔值（有一个满足即返回 `true`）    | ❌ 否           | 判断是否存在符合条件的元素   | ✅ 是（找到第一个满足即停止） | 类似“或”逻辑                                        |
| **`every()`**  | 布尔值（全部满足才返回 `true`）      | ❌ 否           | 判断所有元素是否都符合条件   | ✅ 是（发现不满足即停止）     | 类似“与”逻辑                                        |
| **`find()`**   | 返回第一个满足条件的元素             | ❌ 否           | 查找单个元素                 | ✅ 是（找到即停止）           | 若无符合返回 `undefined`                            |
| **`reduce()`** | 根据回调返回单个累积值               | ❌ 否           | 汇总、统计、扁平化、对象构造 | ❌ 否                         | **第二个参数可指定初始值，回调函数第一个参数为sum** |

### 4. 对象静态方法

| 遍历目标                                        | 方法                                                     | 特点                           |
| ----------------------------------------------- | -------------------------------------------------------- | ------------------------------ |
| 对象本身的可枚举属性（不含继承），不含 `Symbol` | `Object.keys()` / `Object.values()` / `Object.entries()` | 常用，推荐                     |
| 对象本身及继承的可枚举属性，不含 `Symbol`       | `for...in`                                               | 可配合 `hasOwnProperty()` 过滤 |
| 对象本身的所有属性，不含 `Symbol`               | `Object.getOwnPropertyNames()`                           | 包括不可枚举属性               |
| 对象本身的 `Symbol` 属性                        | `Object.getOwnPropertySymbols()`                         | 仅取 Symbol                    |
| 对象本身的所有属性（含 Symbol）                 | `Reflect.ownKeys()`                                      | 最全的方式                     |

