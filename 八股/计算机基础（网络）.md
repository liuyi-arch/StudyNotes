# 计算机基础

## 1. GET和POST的请求的区别

- **从语义上来说，get用于获取资源，post用于提交资源；**
- **数据传输方式上：**
  - **get参数放在url query字符串中，有长度限制，只能传递 ASCII 字符；**
  - **get参数放在http请求体中，理论上无长度限制，可以传输二进制数据；**
- **从安全性上：**
  - **get不会修改服务器数据，是幂等的，能被浏览器缓存；**
  - **post可能会修改服务器数据，是非幂等的，不会被浏览器缓存，因此不能作为书签；**
 
  ❓除get post 方法外，是否还有其他方法？options是什么方法？

## 2. http1.1和2区别？优缺点？http2解决了什么问题？（次重点-仍然有什么解决不了的问题？ http3+udp怎么解决？）

| 特性            | HTTP/1.1                | HTTP/2                 | HTTP/3                     |
| --------------- | ----------------------- | ---------------------- | -------------------------- |
| 连接方式        | 多 TCP 连接（6 个左右） | 单 TCP 连接，多路复用  | 基于 UDP 的 QUIC，多路复用 |
| 队头阻塞        | 有（**应用层**）        | **TCP 层**仍有         | 无（流独立传输）           |
| 报文格式        | 文本                    | 二进制分帧             | 二进制（QUIC）             |
| 头部压缩        | 无                      | HPACK                  | QPACK                      |
| 连接建立速度    | TCP+TLS 多次握手        | TCP+TLS，仍需多次      | 内置 TLS1.3，0-RTT 建连    |
| 兼容性/部署难度 | 广泛兼容，最易部署      | 依赖 HTTPS，部署稍复杂 | 基于 UDP，需要更多支持     |

- **http1.1简单、兼容好，但存在队头阻塞、多连接消耗大的问题；**

  - **多连接消耗大：浏览器需对同一域名开多个 TCP 连接来并行加载资源；**

- **http2通过二进制分帧 + 多路复用 + 头部压缩等技术，相对http1.1极大解决了性能问题，但队头阻塞问题仍然存在；**

  - **二进制分帧：把请求和响应分成小片段（帧），用二进制传输；**

  - **多路复用：同一个 TCP 连接可以同时传多个请求响应；**

- **http3基于UDP彻底消除了队头阻塞，连接更快，更适合移动端和弱网环境；**

## 3. https和http的区别，它⽤了什么机制去保证安全？

- **HTTP 是明文传输，安全性差；HTTPS 在 HTTP 基础上加了 TLS/SSL，使用加密和证书机制保证安全；**
  - **客户端向服务器发起请求，说明支持的加密算法；**
  - **服务器响应客户端，返回数字证书和公钥；**
  - **客户端检查证书是否由可信 CA 签发；**
  - **客户端生成随机对称密钥，用服务器公钥加密发给服务器；**
  - **加密通道建立，双方使用对称密钥加密通信；**

## 4. http状态码？

- **200/201/204 → 成功**
  - 200 OK：请求成功，返回数据放在响应体中；
  - 201 Created：请求成功，并创建了新的资源；
  - 204 No Content：请求成功，但没有返回内容；

- **301/302/304 → 重定向、临时重定向、资源未更改，可直接使用缓存**
  - 301 Moved Permanently：资源已永久移动到新地址；
  - 302 Found（临时重定向）
  - 304 Not Modified：资源未修改，客户端可直接用缓存；

- **400/401/403/404 → 常见客户端错误**
  - 400 Bad Request：请求语法错误或参数错误；
  - 401 Unauthorized：未认证，需要登录或 token；
  - **403 Forbidden：已认证，但没有权限；**
  - **404 Not Found：请求的资源不存在，可能是访问错误的 API 路径；**

- **500/502/503/504 → 常见服务器错误**
  - 500 Internal Server Error：服务器内部错误，后端代码抛异常；
  - 502 Bad Gateway：网关错误，上游服务无响应或响应异常；
  - 503 Service Unavailable：服务器超载或维护中；
  - 504 Gateway Timeout：网关等待上游服务超时；

## 5. 常⻅的http请求⽅法？

- GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS
  - 获取资源、新增/修改资源、整体更新资源、部分更新资源、删除指定资源、获取资源响应头、获取服务器支持的http方法；

## 6. 与缓存相关的HTTP请求头有哪些？

强缓存（响应头、请求头）：

- **Expires：指定缓存过期时间**；

- **Cache-Control**：`max-age=600`缓存 600 秒、`public`允许任何缓存、`private`只能在客户端缓存、`no-cache`可缓存，但使用前必须向服务器验证、`no-store`完全不缓存；

协议缓存（响应头、请求头）：

- **ETag、If-None-Match**：**资源唯一标识**、携带上次响应头中的 `ETag`，**校验资源是否变化**；
- **Last-Modified、If-Modified-Since**：**资源最后修改时间**、携带上次响应头中的 `Last-Modified`，**询问服务器资源是否更新**；

  ❓强缓存、协议缓存应用场景？具体如何使用？
  浏览器发送请求前，
  - （强缓存）先根据请求头的expires和cache-control判断是否命中（是否过期），如果命中，直接使用缓存，如何没有命中，重新请求；
    - 弊端：（浏览器缓存和服务器资源不一致）如果资源变了，但是url没有变化，会使用旧缓存；
    - 使用场景：文件名带hash值的静态资源js/css/图片、带版本号的公共库react等，vite/webpack打包时给文件打上唯一hash值；
  - （协商缓存）发送请求，带着http请求头ETag资源唯一标识 和 If-None-Match资源是否相同、Last-Modified资源最后修改时间 和 If-Modified-Since资源是否修改，如果命中，直接用本地缓存；
    - 使用场景：html文件，频繁变动的数据；

## 7. 输⼊url会发⽣什么？

- 解析 URL → 检查缓存，缓存有效直接返回资源 → 缓存未命中，DNS 解析 → 建立 TCP/HTTPS 连接 → 发送 HTTP 请求 → 服务器处理并返回 → 浏览器解析渲染 → 页面展示
  - 浏览器解析 URL，确定协议（`http/https`）、主机名、端口、路径、查询参数等信息；
  - 浏览器检查缓存，缓存有效直接返回资源；缓存未命中，DNS服务器解析域名，获取服务器IP地址；
  - 浏览器与服务器建立TCP连接（3次握手），如果是HTTPS，还需要进行TLS/SSL握手；
  - 服务器处理请求，服务器返回响应，浏览器解析和渲染；

## 8. 跨域-同源策略？

- 同源策略是浏览器的一种安全策略，要求在协议、域名、端口三者完全一致的情况下，才能读取另一个网页的资源；
- 跨域：两网页不同源，但想访问另外一个网页资源；
- 现代跨域主流解决方案是 CORS + Nginx 代理；
  - CORS：服务端通过设置响应头允许跨域；
  - Nginx：将跨域请求“转发”到同源后端；

  ❓CORS具体如何设置？具体使用？

## 9. 3次握手、4次握手？

- TCP3次握手是建立连接的过程；4次握手是断开连接的过程；
- 三次握手（SYN → SYN+ACK → ACK报文）：希望建立连接；收到请求，发送响应；收到响应，确认连接；
- 四次挥手（FIN → ACK → FIN → ACK报文）：客户端没有数据发送；收到，但服务器可能还需要返回数据；服务器告知客户端没有数据发送；客户端收到，告知服务器
