# HTML

## 1. src与herf的区别？

主要是”用途“和“加载行为”的区别：

- src常用于`<script>、<img>`，会将资源下载到页面中，会**阻塞 HTML 渲染**；
- href常用于 `<link>` 引入样式或 `<a>` 超链接，是引用资源，不会阻塞 HTML 渲染；

## 2. ⻚⾯导⼊样式时，使⽤ link 和 @import 有什么区别？

主要是归属区别、加载区别和兼容性区别：

- `<link>` 是 HTML 标签，页面解析时并行加载，不存在兼容性问题；
- `@import`是CSS语法，页面解析完后加载，是CSS2.1才有的语法，不适用于低版本IE浏览器；

## 3. 🌟对HTML语义化的理解 ？语义化标签？

主要是增强代码可读性，常见语义化标签有`<header>、<footer>、<main>、<nav>、<title>、<p>`；

## 4. script标签中defer和async的区别？

- srcipt默认是同步加载，顺序执行，会阻塞HTML渲染；

- `<script defer>`是异步加载，先执行完HTML解析再执行JS脚本；

- `async` 是异步加载，谁先加载完谁先执行；

  如下图，蓝⾊代表js脚本⽹络加载时间，红⾊代表js脚本执⾏时间，绿⾊代表html解析：	![截屏2025-07-30 10.08.20](/Users/liuliu/Desktop/截屏2025-07-30 10.08.20.png)

## 5. meta标签？

用于设置页面基础配置，比较熟悉的有：

- `<meta charset="UTF-8">`用于设置编码，防止乱码；
- `<meta name="viewport">`移动端适配；

## 6. 🌟HTML5有哪些更新？

- 新的选择器`document.querySelector`、`document.querySelectorAll`；
- 音媒体`<audio>`、`<video>`标签，此前`flash`实现；
- 本地存储：`localStorage`、`sessionStorage`；
- 语义化标签；
- 浏览器通知`Notifications`、地理位置`Geolocation`；
- 扩展表单组件：新增`<input>`类型，如`data`、`range`、`email`；
- `WebSocket`支持全双工通信；
- 多任务处理`web worker`；

## 7. 对Web Worker的理解？

- Web Worker 是一种浏览器的多线程技术，允许在后台线程中运行 JavaScript 代码，避免阻塞主线程；
- 但是Worker 不能直接访问 DOM、`window` 或 `document`，只能通过消息传递来交换数据（使用 `postMessage` 和 `onmessage`）；

## 8. `<!DOCTYPE>`作用是什么？标准模式与兼容模式各有什么区别？

- 告诉浏览器以标准规范解析网页，若DOCTYPE 不存在则会以兼容模式呈现；
- 标准模式的渲染⽅式和 JS 引擎的解析⽅式都是以该浏览器⽀持的最⾼标准运⾏；
- 兼容模式中，⻚⾯以宽松的向后兼容的⽅式显示；

## 9. ⾏内元素有哪些？块级元素有哪些？ 空(void)元素有那些？

- 行内元素：`span input img button label`等；
- 块级元素：`div p title h1 ul ol li`等；
- 空元素即没有闭合标签元素：`<input> <img> <link> <meta>`等；

## 10. img标签title、alt、srcset?

- alt：图⽚加载失败时，显示alt的内容，利于SEO（搜索引擎更好地理解图片内容）；

- title：⿏标移动到图⽚上时，显示title的内容；

- srcset：不同设备或屏幕尺寸下加载的不同图像，提升响应式设计和图片加载性能；

  ```html
  <img src="small.jpg" srcset="large.jpg 1024w, medium.jpg 640w" alt="响应式图片">
  ```

## 11. iframe?

- `iframe` 是在当前页面中嵌入另一个 HTML 页面，可以用来嵌入广告、第三方组件、跨域页面、文档预览等；
- 但 `iframe` 存在一些性能和安全问题，比如阻塞父页面加载、跨域限制、SEO 不友好；

```html
<iframe src="https://example.com" width="600" height="400"></iframe>
```

## 12. title与h1的区别、b与strong的区别、i与em的区别？

- **`<title>`** 是网页标题，鼠标hover至浏览器标签页显示标题；**`<h1>`** 是网页内容标题，用于页面主体结构，且有明确层级；
- **`<b>`** 是加粗但没有语义；**`<strong>`** 加粗并表示“强调”；
- **`<i>`** 是斜体没有语义；**`<em>`** 表示“强调”，默认也是斜体，能被语音设备识别；

## 13. head 标签有什么作⽤

- `<head>` 是 HTML 页面中非可视化部分的容器，用来引⽤脚本、指示样式表、放置页面元信息；
- `<title>`网页标题、`<meta>`编码方式、`<link>`引入外部CSS文件、`<style>`页面样式、`<script>`JS脚本；
- 其中`<title>`是head部分唯一必需的元素；

## 14. 布局模型

- Normal Flow流动模型：标准文档流布局；
- Float浮动模型：常用于图文混排，脱离文档流，需清楚浮动；
- Position层模型：可实现悬浮按钮；

# css八股

## 1. flex布局✅8.11✅

容器上属性：

- flex-direction、flex-wrap、justify-content、align-items、align-content；
- 设置主轴（默认左右）方向、是否换行、沿主轴（默认左右）对齐方式、沿交叉轴（默认上下）对齐方式、交叉轴多行对齐方式；



项目上属性：

- flex-grow、flex-shrink、flex-basis、align-self；
- 占剩余空间的比例、空间不足时缩小比例、项目初始大小、单个项目交叉轴对齐方式；



特点：可根据容器大小自动收缩，无需计算margin；适用于一维布局，比如导航栏，二维采用grid布局；

图示参考css-tricks：https://css-tricks.com/snippets/css/a-guide-to-flexbox/

## 2. 两栏布局三栏布局✅8.12

P58



## 3. bfc✅8.12

P57

## 4. 居中✅8.12

P59

## 5. 响应式布局✅8.11✅

响应式与自适应：

- 响应式：一个页面，自动伸缩；能够自适应不同设备屏幕大小；

- 自适应：多个固定宽度版本，根据设备选择其一；



em、rem、vw、vh：

- em：基于当前元素font-size计算；1em = 当前元素的 font-size；层层父元素，还可能继承父元素font-size，计算复杂；
- rem：基于html根元素font-size计算；1rem = html 的 font-size；方便全局缩放，改根font-size，全局尺寸同步变；
- vw\vh：1vw = 视口宽度的 1%；



其他：

- 控制上下限防止字体太大太小：`html { font-size: clamp(14px, calc(100vw / 7.5), 20px); }`
- 满屏宽高使用vw/vh；
- postcss-pxtorem：px转rem；postcss-px-to-viewport：px转vw；

## 6. display✅8.12

## 7. position✅8.12

## 8. css3新特性

## 9. 伪类与伪元素区别

## 10. 画三角形

# js八股

## 1. Call、apply、bind？

它们共同点主要有两点：

- 作用都是**手动指定函数的`this` 指向**；
- **第一个参数是 `this` 要指向的对象**：
  - 如果参数为 `null` 或 `undefined`，在非严格模式下默认指向全局对象 `window`；
  - 严格模式下，`this` 会保留为 `null` 或 `undefined`，不会自动绑定到 `window`；

它们主要区别在于是否**立即执行、参数形式、this是否永久绑定**：

| 方法    | 是否立即执行 | 参数形式                                    | this 是否永久绑定 |
| ------- | ------------ | ------------------------------------------- | ----------------- |
| `call`  | 是           | 参数列表：call(thisArg, arg1, arg2, ...)    | 否                |
| `apply` | 是           | 参数数组：apply(thisArg, [arg1, arg2, ...]) | 否                |
| `bind`  | 否           | 参数列表（可分批，柯里化）：同call          | 是                |

关于call、apply一次绑定，bind永久绑定：

```js
// call一次绑定
function sayHi() {
  console.log(this.name);
}
const person = { name: 'Alice' };
sayHi.call(person); // "Alice"
sayHi();            // undefined（或 window.name）

// bind永久绑定
const boundSayHi = sayHi.bind(person);
boundSayHi();       // "Alice"
boundSayHi.call({ name: 'Bob' }); // "Alice"
```

## 2. this指向？

主要分为7种大的情况：

- 全局作用域下调用：
  - 浏览器环境，指向window；
  - node环境，this指向module.exports；
    - Node.js 使用 CommonJS 模块系统，每个文件都是一个模块，module.exports是该文件模块顶层作用域；
- 普通函数内调用：
  - 非严格模式，this指向全局对象；具体细分，浏览器环境指向window，node环境指向global；
  - 严格模式，this两种环境都是指向undefined；
- 谁调用指向谁：
  - 函数作为某对象的方法被该对象调用：this指向该对象；
  - 构造函数调用：this指向新创建的实例对象；
- 显示绑定this，指向绑定的对象；
- 事件处理程序中this指向的是事件源；
- 特殊情况：
  - 箭头函数没有自己this，它沿着作用域链继承外层普通函数的this；
  - **定时器处理函数、匿名函数指向window**；
- 赋值或运算符导致 this 丢失；

优先级（由高到低）：

**`new` 构造函数 > `bind` 显式绑定 > `call` / `apply` 显式绑定 > 箭头函数 > 对象方法调用 > DOM 事件处理函数 > 定时器函数 > 自执行函数 > 普通函数直接调用**

下列解释深拷贝部分代码this指向：

```js
if (typeof obj === 'function') {
    return function (...args) {
        return obj.call(this, ...args); // 拷贝函数本体功能和保留this的动态绑定特性（即谁调用指向谁），而不拷贝函数运行时的内存结构，比如函数的闭包上下文；
    }
}

// obj.call(this , ...args)，将绑定到调用该函数的对象上；
// obj.call(...args)，call没有设置第一个参数，那么将指向全局；
```

## 3. var let const?

| 特性             | var                         | let                                  | const                                |
| ---------------- | --------------------------- | ------------------------------------ | ------------------------------------ |
| 作用域           | 函数作用域                  | 块级作用域                           | 块级作用域                           |
| 变量提升         | 有提升，声明前访问undefined | 有提升，声明前访问ReferenceError错误 | 有提升，声明前访问ReferenceError错误 |
| 暂时性死区 (TDZ) | 无                          | 有                                   | 有                                   |
| 重复声明         | 可以                        | 不可以                               | 不可以                               |
| 重新赋值         | 可以                        | 可以                                 | 不可以                               |

关于const使用场景误区：

```js
// 错误
for(const i = 0;i < 10;i++){
    console.log(i);
}
// 正确
for (const key in obj) {
    console.log(key);
}
```

- for循环中，每轮循环i被重新赋值，是同一个i；
- for...in或for...of循环中，每次迭代都是一个新的key；

（补充）关于提升：函数声明提升，函数表达式不提升；还有诸如class提升、import提升；

详细见：https://github.com/liuyi-arch/StudyNotes/blob/main/step2%20Javascript/1%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8F%90%E5%8D%87.md

## 4. 原型与原型链

**1. `prototype、__proto__、constructor`：**

- prototype：构造函数有的属性；
- `__proto__`实例对象内部的[[prorotype]]属性；
- constructor：每个prototype对象都有一个constructor属性，可以指回原构造函数；

关系：

```js
person.__proto__ === Person.prototype;
Person.prototype.constructor === Person
```



**2. 原型链：**访问某个对象的属性或方法时，如果该对象自身没有，那么会延着`__proto__`向上查找；

关系：

```js
person.__proto__ === Person.prototype;
Person.prototype.__proto__ === Object.prototype;
Object.__proto__ === null;
```

**3. 重写原型对象，要手动将constructor补回来：**

```js
// 会丢掉constructor属性
function Person(name) {
    this.name = name;
}
Person.prototype = {
    sayHi() {
        console.log(`Hi, I'm ${this.name}`);
    }
};

// 正确写法
function Person(name) {
    this.name = name;
}
Person.prototype = {
    constructor: Person, // 手动补回
    sayHi() {
        console.log(`Hi, I'm ${this.name}`);
    }
};
```

**4. `__proto__`是非标准属性，现代写法使用`Object.getPrototypeOf(obj)`代替**，见如下示例：

```js
// 示例1
console.log(Person.prototype.__proto__.name);
console.log(Object.getPrototypeOf(Person.prototype).name);

// 示例二
console.log(p1.__proto__.name);
console.log(Person.getPrototypeOf(p1).name);
```

## 5. Promise理解？

背景：Promise之前，如果要处理异步问题，需要层层callback function；

```js
setTimeout(function () {
    console.log("1");
    setTimeout(function () {
        console.log("2");
        setTimeout(function () {
            console.log("3");
        }, 3000);
    }, 2000);
}, 1000);
```

下面将使用Promise链、async/await改写上述callback function：

```js
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Promise链
sleep(1000)
  .then(() => {
    console.log("1");
    return sleep(2000);
  })
  .then(() => {
    console.log("2");
    return sleep(3000);
  })
  .then(() => {
    console.log("3");
  })
  .catch(err => {
    console.error('出错了：', err);
  });

// async/await
async function run() {
  try {
    await sleep(1000);
    console.log("1");

    await sleep(2000);
    console.log("2");

    await sleep(3000);
    console.log("3");
  } catch (err) {
    console.error('出错了：', err);
  }
}

run();
```



概念：

- **核心作用**：用来处理异步操作，避免回调地狱，支持链式调用；

- 是一个构造函数，接受一个函数作为参数，返回一个 Promise 实例；

- 有以下特点：

  - **状态不可逆**：一旦从 `pending` 变成 `fulfilled` 或 `rejected`，就不能再改变。

  - **then/catch 总是异步执行**：即使 Promise 已经是 fulfilled 状态，回调也会进入 **微任务队列**。

  - **值穿透**：如果 `then()` 没有返回值，会自动将上一个值传递下去。

  - **错误冒泡**：未捕获的错误会沿着链条冒泡到最近的 `catch()`。



使用：

- resolve函数作用是将Promise的状态从pending改变成fufilled，**触发 then 的第一个回调**；
  - `resolve()`：状态变为 fulfilled，`then` 会被触发，回调的参数是 `undefined`；
  - `resolve(value)`：状态变为 fulfilled，`then` 的回调会接收到 `value`；
  - 如果不使用resolve()，状态仍为pending，无法触发then；
- reject函数作用是将Promise的状态从pending改变成rejected，**触发 then 的第二个回调或 catch** ；
- pending状态then、catch、finally都不能触发；

```js
const p = new Promise((resolve, reject) => {
    setTimeout(() => {
        const success = true;
        if (success) {
            // resolve("数据加载成功");
            console.log("数据加载成功");
        } else {
            // reject("数据加载失败");
            reject();
        }
    }, 1000);
});

p.then(result => {
    console.log("成功:", result);
}).catch(error => {
    console.error("失败:", error); // 失败: 数据加载失败
}).finally(() => {
    console.log("无论成功还是失败都会执行"); // 无论成功还是失败都会执行
});
```



async/await：

- then 和 await 在本质上都是等待 Promise resolve 后再执行下一个；
- 使用try/catch语法包裹await，错误全部在catch中抛出，代码结构比then更像同步；



Promise常用API：

- `then(onFulfilled, onRejected)` → 处理成功与失败

- `catch(onRejected)` → 处理失败

- `finally(onFinally)` → 无论结果都会执行

- `Promise.all(iterable)` → 全部成功才成功，任一失败即失败

- `Promise.race(iterable)` → 最快的一个决定结果

- `Promise.allSettled(iterable)` → 等待所有完成，返回每个结果状态数组

## 6. js有哪些数据类型？判断数据类型方法？

基本数据类型：Number、String、Boolean、null、undefined、BigInt、Symbol；

复杂数据类型：Object、Array、Function、Date、RegExp、Map、Set、WeakMap、WeakSet等；

> 1. Synbol类型有两种创建方式：Symbol()、Symbol.for()，其中Symbol()创建的值是唯一的，Symbol.for()创建的值是共享的；
> 2. Symbol类型作为键使用时，不会被for...in等方式访问到；



数据类型检测：

- `typeof xx`：设计缺陷，对null判断是object；
- `Object.prototype.toString.call(xx)`：最准确，适用所有数据类型；
- `person instanceof Person`：判断实例对象是否是构造函数的实例；



数据类型赋值：

- 基本数据类型存储的是实际值、复杂数据类型存储的是引用地址；
- 要实现复杂数据类型浅拷贝，比如数组：`res.push([...path])`；



数据类型转换：

- 隐式转换：
  - 字符串拼接，比如1 + '2' -> '12'；
  - 字符串、boolean转化为数字，比如'2' - 1 -> 1、1 + true -> 2等；
- 显式转换：
  - 转换为数字：Number(xx)、parseInt(xx)、parseFloat(xx)等；
  - 转换为字符串：String(xx)、xx.toString()等；
  - 转换为boolean值：Boolean(xx)；

## 7. js常用数组方法？哪些数组方法不改变原数组？

增、删、查：

- arr.push(x)末尾添加；arr.unshift(x)开头添加；
- arr.pop()末尾删除；arr.shift()开头删除；
- indexOf(value)已知值找索引；includes(value)是否包含值；
  - 其他：lastIndexOf()、find(callback)、findIndex(callback)；



按分割符连接、拆分与数组合并、截取：

- arr.join(',')、split('-')；
- arr1.concat(arr2)、arr.slice(start , end)，[start , end)；



过滤、映射、遍历、叠加计算、some/every：

- arr.filter(num => num % 2 === 0)，留下能整除2的元素，返回新数组；
- arr.map(num => num * num)，所有元素开平方，返回新数组；
- arr.forEach((value , index) => console.log(value , index))，无返回数组；
- arr.reduce((sum , num) => sum + num , 0)，叠加计算，第二个参数为sum初始值；
- arr.some(num => num % 2 === 0)，数组是否有偶数；arr.every(num => num % 2 === 0)，数组是否全是偶数；



除增、删，其余数组操作全部不改变原数组；

## 9. ES6新特性？

1. 新的声明方式const、let：块级作用域、存在变量提升，但存在暂时性死区、const声明常量；
2. 新的数据结构：Set()不重复集合、Map()键值对，键可以是任何类型；
3. 新的数据类型Symbol()：唯一的值，常用于私有属性；Symbol.for()共享值；作为键使用不会被for...in访问到；
4. 新的遍历方式：for...of用于数组，for...in用于对象；
5. 箭头函数：没有this绑定，继承外层函数的this、不能用作构造函数，没有prototype、没有arguments对象；
6. 展开运算符：可用于浅拷贝、合并数组或对象；
7. Promise；
8. 类class与继承：super()与extends；
9. 模版字符串${}、参数默认值、解构赋值、对象字面量；

## 10. 箭头函数？

特点：

- 无function，无函数名；



与普通函数比较：

- 箭头函数没有自己this(因此也不能call/apply/bind绑定)，它沿着作用域链继承外层普通函数的this，如果**外层没有普通函数，那么继承全局作用域this**(严格模式指向undefined，非严格模式指向window)；

  - 而普通函数this指向取决于谁调用它；

  ```js
  const obj = {
    value: 42,
    normal: function() {
      console.log(this.value);
    },
    arrow: () => {
      console.log(this.value);
    }
  };
  
  obj.normal(); // 42 (this -> obj)
  obj.arrow();  // undefined (this -> 外层作用域，全局)
  ```

- 不可用做构造函数、没有prototype属性、没有arguments对象（保存实参列表，arguments现已被剩余参数取代）；

  - 类继承必须先super()再使用this；



使用场景：

- 适用于回调函数，比如定时器；

- 不适用于需要动态绑定的**方法**；

  ```js
  // 例1:用箭头函数
  class Person {
    constructor(name) {
      this.name = name;
    }
  
    startTalking() { 
      setInterval(() => { 
        console.log(this.name);
      }, 1000);
    }
  }
  
  const p = new Person("Alice");
  p.startTalking();
  
  
  // 例2:不适用于箭头函数
  const obj = {
    name: "Alice",
    say: () => {
      console.log(this.name);
    }
  };
  
  obj.say(); // undefined（因为 this 外层没有普通函数，则指向 window，而不是 obj）
  ```

  例1中：

  - 使用箭头函数，this指向外层函数，即Person(构造函数也是函数)，那么p.startTalking(),this指向Person的实例对象p；
  - 使用普通函数，那么定时器中this指向的是全局；

## 11. 闭包？

词法作用域：取决于函数定义时所处的环境，而不是调用位置；

Javascript使用的是词法作用域；

> 动态作用域中，函数内部的变量查找是从调用它的位置向上查找；

```js
var value = 1;

function foo() {
    console.log(value); // 1
}

function bar() {
    var value = 2;
    foo();
}

bar();
```



闭包ECMAScript定义：即使创建词法环境的执行上下文不在活跃，外层引用仍然可能保留；

自己理解：函数返回后仍然可以访问其定义时的词法作用域；



闭包好处：变量私有化、持久化变量；

闭包缺点：长期占用内存；

## 12. 事件循环机制？宏任务/微任务？

同步异步、串行并行：

- 同步：任务按顺序执行，前一个没完成，后一个必须等待；
- 异步：不必立即执行，可以挂起；
- 串行：任务一个接一个执行，后面任务必须等前面完成才执行；
- 并行：多个任务同时执行，需多线程支持；



常见宏任务与微任务：

- 宏任务：`<script>`脚本、setTimeout/setInterval、postMessage、I/O（涉及外部设备交互的操作）、用户交互事件（点击、键盘事件等）；
- 微任务：Promise.then/catch/finally等；



事件循环机制：

- JavaScript 是单线程的，依赖事件循环机制来调度同步和异步任务；
- 优先级：同步任务高于异步任务（宏任务、微任务）；微任务高于宏任务；

```js
console.log('start');

setTimeout(() => {
  console.log('macro task');
}, 0);

Promise.resolve().then(() => {
  console.log('micro task 1');
}).then(() => {
  console.log('micro task 2');
});

console.log('end');

// 输出结果
start
end
micro task 1
micro task 2
macro task
```

参考：https://www.lydiahallie.com/blog/event-loop

# 计算机基础

## 1. GET和POST的请求的区别

- **从语义上来说，get用于获取资源，post用于提交资源；**
- **数据传输方式上：**
  - **get参数放在url query字符串中，有长度限制，只能传递 ASCII 字符；**
  - **get参数放在http请求体中，理论上无长度限制，可以传输二进制数据；**
- **从安全性上：**
  - **get不会修改服务器数据，是幂等的，能被浏览器缓存；**
  - **post可能会修改服务器数据，是非幂等的，不会被浏览器缓存，因此不能作为书签；**

## 2. http1.1和2区别？优缺点？http2解决了什么问题？（次重点-仍然有什么解决不了的问题？ http3+udp怎么解决？）

| 特性            | HTTP/1.1                | HTTP/2                 | HTTP/3                     |
| --------------- | ----------------------- | ---------------------- | -------------------------- |
| 连接方式        | 多 TCP 连接（6 个左右） | 单 TCP 连接，多路复用  | 基于 UDP 的 QUIC，多路复用 |
| 队头阻塞        | 有（**应用层**）        | **TCP 层**仍有         | 无（流独立传输）           |
| 报文格式        | 文本                    | 二进制分帧             | 二进制（QUIC）             |
| 头部压缩        | 无                      | HPACK                  | QPACK                      |
| 连接建立速度    | TCP+TLS 多次握手        | TCP+TLS，仍需多次      | 内置 TLS1.3，0-RTT 建连    |
| 兼容性/部署难度 | 广泛兼容，最易部署      | 依赖 HTTPS，部署稍复杂 | 基于 UDP，需要更多支持     |

- **http1.1简单、兼容好，但存在队头阻塞、多连接消耗大的问题；**

  - **多连接消耗大：浏览器需对同一域名开多个 TCP 连接来并行加载资源；**

- **http2通过二进制分帧 + 多路复用 + 头部压缩等技术，相对http1.1极大解决了性能问题，但队头阻塞问题仍然存在；**

  - **二进制分帧：把请求和响应分成小片段（帧），用二进制传输；**

  - **多路复用：同一个 TCP 连接可以同时传多个请求响应；**

- **http3基于UDP彻底消除了队头阻塞，连接更快，更适合移动端和弱网环境；**

## 3. https和http的区别，它⽤了什么机制去保证安全？

- **HTTP 是明文传输，安全性差；HTTPS 在 HTTP 基础上加了 TLS/SSL，使用加密和证书机制保证安全；**
  - **客户端向服务器发起请求，说明支持的加密算法；**
  - **服务器响应客户端，返回数字证书和公钥；**
  - **客户端检查证书是否由可信 CA 签发；**
  - **客户端生成随机对称密钥，用服务器公钥加密发给服务器；**
  - **加密通道建立，双方使用对称密钥加密通信；**

## 4. http状态码？

- **200/201/204 → 成功**
  - 200 OK：请求成功，返回数据放在响应体中；
  - 201 Created：请求成功，并创建了新的资源；
  - 204 No Content：请求成功，但没有返回内容；

- **301/302/304 → 重定向、临时重定向、资源未更改，可直接使用缓存**
  - 301 Moved Permanently：资源已永久移动到新地址；
  - 302 Found（临时重定向）
  - 304 Not Modified：资源未修改，客户端可直接用缓存；

- **400/401/403/404 → 常见客户端错误**
  - 400 Bad Request：请求语法错误或参数错误；
  - 401 Unauthorized：未认证，需要登录或 token；
  - **403 Forbidden：已认证，但没有权限；**
  - **404 Not Found：请求的资源不存在，可能是访问错误的 API 路径；**

- **500/502/503/504 → 常见服务器错误**
  - 500 Internal Server Error：服务器内部错误，后端代码抛异常；
  - 502 Bad Gateway：网关错误，上游服务无响应或响应异常；
  - 503 Service Unavailable：服务器超载或维护中；
  - 504 Gateway Timeout：网关等待上游服务超时；

## 5. 常⻅的http请求⽅法？

- GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS
  - 获取资源、新增/修改资源、整体更新资源、部分更新资源、删除指定资源、获取资源响应头、获取服务器支持的http方法；

## 6. 与缓存相关的HTTP请求头有哪些？

## 7. 输⼊url会发⽣什么？

- 解析 URL → 检查缓存，缓存有效直接返回资源 → 缓存未命中，DNS 解析 → 建立 TCP/HTTPS 连接 → 发送 HTTP 请求 → 服务器处理并返回 → 浏览器解析渲染 → 页面展示
  - 浏览器解析 URL，确定协议（`http/https`）、主机名、端口、路径、查询参数等信息；
  - 浏览器检查缓存，缓存有效直接返回资源；缓存未命中，DNS服务器解析域名，获取服务器IP地址；
  - 浏览器与服务器建立TCP连接（3次握手），如果是HTTPS，还需要进行TLS/SSL握手；
  - 服务器处理请求，服务器返回响应，浏览器解析和渲染；

## 8. 跨域-同源策略？

- 同源策略是浏览器的一种安全策略，要求在协议、域名、端口三者完全一致的情况下，才能读取另一个网页的资源；
- 跨域：两网页不同源，但想访问另外一个网页资源；
- 现代跨域主流解决方案是 CORS + Nginx 代理；
  - CORS：服务端通过设置响应头允许跨域；
  - Nginx：将跨域请求“转发”到同源后端；

## 9. 3次握手、4次握手？

- TCP3次握手是建立连接的过程；4次握手是断开连接的过程；
- 三次握手（SYN → SYN+ACK → ACK报文）：希望建立连接；收到请求，发送响应；收到响应，确认连接；
- 四次挥手（FIN → ACK → FIN → ACK报文）：客户端没有数据发送；收到，但服务器可能还需要返回数据；服务器告知客户端没有数据发送；客户端收到，告知服务器

# js手写

## 1. 防抖、节流✅8.11✅

- 防抖：**在事件被触发n秒后再执⾏回调函数。如果在这段时间内⼜触发了该事件，则重新计时**。⽐如，在输⼊框搜索时，⽤户连续输⼊字符，我们不希望每次输⼊都触发搜索请求，⽽是在⽤户停⽌输⼊⼀段时间后再触发搜索请求。

- 节流：在**每隔n秒后执⾏⼀次回调函数**。⽐如，当⽤户滚动⻚⾯时，我们不希望每次滚动都触发相应的操作，⽽是每隔⼀段时间才执⾏⼀次操作。
- 注意：防抖节流函数优化版本都是首次立即执行。

P74-78

```js
// 防抖函数：版本1
function debounce(fn , delay = 300){
  let timer = null;
  return function(...args){
    if(timer) clearTimeout(timer);
    timer = setTimeout(() => { fn.call(this , ...args) } , delay);
  }
}

// 防抖函数-版本2
function debounce(fn , delay = 300 , immediate = false){
  let timer = null;
  let invoked = false; // 第一次点击立即执行
  return function(...args){
    const context = this;
    if(timer) clearTimeout(timer);
    if(immediate && !invoked){
      fn.call(context , ...args);
      invoked = true;
    }else{
      timer = setTimeout(() => { 
      	fn.call(context , ...args);
      	invoked = false;
      } , delay);
    }
  }
}

window.onresize = debounce(function() {
  console.log('window onresize end');
}, 500)
```

```js
// 节流函数-版本1
function throttle(fn, interval) {
  var timer = null;
  var firstTime = true;
  var _self = fn;
  return function() {
    var that = this;
    var args = arguments;
    // 判断是否第一次执行
    if(firstTime) {
      _self.apply(that, args);
      return firstTime = false;
    }
    // 判断定时器是否执行完毕
    if(timer) {
      return false;
    }
    // 设置定时器
    timer = setTimeout(function() {
      clearTimeout(timer);
      timer = null;
      _self.apply(that,args);
    }, interval || 500)
  }
}
window.onresize = throttle(function() {
  console.log('window onresize');
}, 500)

// 节流函数-版本1
function throttle(fn , delay = 300){
  let last = 0;
  return function(...args){
    const now = Date.now();
    if(now - last >= delay){
      fn.apply(this , args);
      last = now;
    }
  }
}

// 节流函数-版本2

```

## 2. 深浅拷⻉✅8.3✅

P79-81

```js
// 浅拷贝
function shallow(obj) {
    const newObj = {};
    for (const key in obj) {
        newObj[key] = obj[key];
    }
    return newObj;
}

// 深拷贝-base版
function deepCopy(obj , cache = new WeakMap()){ // 默认参数，WeakMap 是一种键名只能是对象的键值对集合，用于记录该对象是否已被复制，避免重复拷贝和循环引用；
  if(obj === null || typeof obj !== 'object') return obj; // 原始数据类型直接返回；
  if(obj instanceof Date) return new Date(obj); // 内建对象不能用{}或[]拷贝；
  if(obj instanceof RegExp) return new RegExp(obj);
  if(obj instanceof Error) return new Error(obj.message); // 只返回报错message，不返回报错stack（即控制台报错的at <anonymous>...）；
  if(typeof obj === 'function'){
    return function(...args){
      return obj.call(this , ...args); // 拷贝函数本体功能和this传递（即谁调用指向谁），而不拷贝函数运行时的内存结构，比如函数的闭包上下文；
    }
  }
  
  if(cache.has(obj)) return cache.get(obj); // 比如，如果有obj.seft = obj，而没有cache缓存判断是否已被复制，那么将循环引用；
  const newObj = Array.isArray(obj) ? [] : {};
  cache.set(obj , newObj);
  
  for(const key in obj){
    if(obj.prototype.hasOwnProperty.call(value , key)){ // obj.prototype.hasOwnProperty.call(value , key)判断一个对象自身是否有某个属性，而不是继承来的属性，obj.hasOwnProperty(key)写法不能区分后者；
      newObj[key] = deepCopy(obj[key] , cache);
    }
  }
  
  return newObj;
}


// 深拷贝-large版
function deepCopy(obj, cache = new WeakMap()) {
  // 处理原始类型和 null
  if (obj === null || typeof obj !== 'object') return obj

  // 处理特殊对象
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)
  if (obj instanceof Error) return new Error(obj.message)
  if (typeof obj === 'function') {
    return function (...args) {
      return obj.apply(this, args)
    }
  }

  // 处理循环引用
  if (cache.has(obj)) return cache.get(obj)

  // 处理 Map
  if (obj instanceof Map) {
    const result = new Map()
    cache.set(obj, result)
    obj.forEach((value, key) => {
      result.set(deepCopy(key, cache), deepCopy(value, cache))
    })
    return result
  }

  // 处理 Set
  if (obj instanceof Set) {
    const result = new Set()
    cache.set(obj, result)
    obj.forEach(value => {
      result.add(deepCopy(value, cache))
    })
    return result
  }

  // 普通对象/数组
  const result = Array.isArray(obj) ? [] : {}
  cache.set(obj, result)

  // 支持 Symbol 属性
  const keys = Reflect.ownKeys(obj)
  for (const key of keys) {
    result[key] = deepCopy(obj[key], cache)
  }

  return result
}
```

## 3. promise.all✅8.13✅

P86-89

```js
function promiseAll(promises){
  return new Promise((resolve, reject) => {
    if(!Array.isArray(promises)) return reject(new TypeError('Promise.all 输入需要是数组'));
    
    const res = [];
    let pendingCount = promises.length;
    
    if(pendingCount === 0) return resolve([]);
    
    promises.forEach((item, index) => {
      Promise.resolve(item)
      	.then(value => {
        	res[index] = value;
        	pendingCount--;
        	if(pendingCount === 0) resolve(res);
      })
      .catch(reject);
    })
  })
}

// promises示例
const promises = [
 Promise.resolve('First'),
 Promise.reject('Rejected'),
 Promise.resolve('Third')
];
```

## 4. new✅8.11✅

P79 

```js
function myNew(Constructor, ...args){
  const obj = Object.create(Constructor.prototype); // 创建一个Constructor类型的实例对象，并将obj.__proto__指向Constructor.prototype
  const result = Constructor.apply(obj, args); // 执行构造函数并将this绑定到obj
  return (result !== null && (typeof result === 'object' || typeof result === 'function')) ? result : obj; // 原始数据类型不能不能挂原型链，也不能用new创建原始数据类型的实例
}
 
// myNew和new创建实例对象示例
function Person(name, age){
  this.name = name;
  this.age = age;
}

let person1 = new Person('zhangsan', 20); // {name: 'zhangsan', age: 20}
let person2 = myNew(Person, 'lisi', 30); // {name: 'lisi', age: 30}
```

## 5. instanceof✅8.3✅

P80

- `instanceof`用于判断一个对象是否是某个构造函数构造的实例：`object instanceof Constructor`；

- 它的判断逻辑是：沿着对象的原型链向上查找，看是否有原型等于 `Constructor.prototype`；

```js
function myInstanceof(left , right){
  if(typeof left === null || typeof left !== 'Object') return false;
  let proto = Object.getPrototypeOf(left);
  let prototype = right.prototype;
  while(proto !== null){ // 沿着原型链查找，直到null；
    if(proto === prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

- `instanceof` 是用来判断 **某个对象**是否是 **某个构造函数构造的实例**，而原始数据类型（ `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`）**不是对象**，没有原型链，**无法参与原型查找**，所以使用 `instanceof` 判断返回 `false`；

- `Object.getPrototypeOf(obj)`等价于`obj.__proto__`（非标准写法）：

  ```js
  Object.getPrototypeOf(person) === Person.prototype;
  Object.getPrototypeOf(Person.protorype) === Object.prototype;
  Object.getPrototypeOf(Object.prototype) === null;
  ```

## 6. flat（数组扁平化）✅8.13✅

P81

- 扁平化就是把嵌套的数组变成“少一层或多层嵌套”的数组；

- 例如把 `[1, [2, [3, 4]], 5]` 扁平 1 层得到 `[1, 2, [3, 4], 5]`，扁平无限层（完全扁平）得到 `[1,2,3,4,5]`；

```js
// 数组扁平化
const flat = (arr, depth = 1){
  depth > 0
  	? arr.reduce((acc, cur) =>
    		arr.concat(Array.isArray(cur) ? flat(cur, depth - 1) : cur), [])
  	: arr.slice(); // 实现数组的浅拷贝，slice()不指定参数是浅拷贝，指定参数为截取，也可以使用[...arr]
}

// 对象扁平化
function objectFlat(obj = {}) {
  const res = {}
  function flat(item, preKey = '') {
    Object.entries(item).forEach(([key, val]) => {
      const newKey = preKey ? `${preKey}.${key}` : key
      if (val && typeof val === 'object') {
        flat(val, newKey)
      } else {
        res[newKey] = val
      }
    })
  }
  flat(obj)
  return res
}	
```

## 7. call✅8.12✅

P82 

call：**让一个对象obj临时“拥有”某个函数func，并立即调用这个函数**，同时还能传入参数

```js
func.call(obj, ...args) // 如果obj为undefined或null，那么func的this指向为全局而不是obj
```

- 把 `func` 挂到 `obj` 上；

- 然后用obj调用func，传入实参为arg1、arg2等，这样 `this` 就指向了 `obj`；
- 调用完之后再把func方法从obj删掉；

```js
// call是Function原型上的方法，看原生call绑定代码帮助理解`func.call(obj , ...args)`
Function.prototype.myCall = function(thisArg , ...args){
	if(typeof this !== 'function'){
    throw new TypeError(this + 'is not a function');
  }
  
  // globalThis为不同运行环境中的全局对象，Object(thisArg)包装为Object类型
  thisArg = (thisArg === undefined || thisArg === null) 
    ? globalThis : Object(thisArg) 
  
  // 将func添加到obj，这里也就是thisArg上
  const fnKey = Symbol('fn'); // Symbol避免thisArg中属性冲突，这里的fn只是描述，供调试用
  thisArg[fnKey] = this; // .语法无法访问Symbol属性，必须使用[]，也就是for...in不能将Symbol类型枚举出来
  
  const res = thisArg[fnKey](...args); // 执行func，然后将func从thisArg上删除
  delete thisArg[fnKey];
  
  return res;
}
```

## 8. 函数柯⾥化✅8.12✅

柯里化：把一个接受多个参数的函数，转换成一系列每次只接受一个参数的函数；即让函数“分步接收参数”，而不是一次性接收所有参数；

```js
function curry(fn){
  return function curried(...args){
    if(args.length >= fn.length){
      return fn.apply(this, args);
    }else{
      return (...rest) => curried.apply(this, [...args, ...rest]);
    }
  }
}

// 调用示例
function add(a, b, c){
  return a + b + c;
}

const addCurry = curry(add);
addCurry(1)(2)(3);
```

- **fn.length函数定义时**声明的形参个数，不包括rest参数和默认值的参数；
- args.length表示已收集到的参数数量；
- rest为后传递进来的参数，[...args, ...rest]表示将先后传递进来的参数合并；

P82-83

## 9. 数组api

P89

## 10. url解析、千分位隔开

P83-84 p91-92

## 11. 数组转树 暴⼒递归和哈希解法

P70 

---

# leetcode

## 1. 基础前置知识

### 1.0 其他

#### 1.0.1 运算符优先级

### 1.1 链表

#### 1.1.1 链表节点定义

```js
// 区别？
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val)
    this.next = (next === undefined ? null : next)
}

function ListNode(val){
  this.val = val;
  this.next = null;
}
```

### 1.2 数组

#### 1.2.1 常用函数

##### slice(m , n)：截取[m , n)

##### substring(m, n)：截取[m , n]

##### 

数组、字符串增删改查、遍历与截取；

哈希表增删改查与遍历；

#### 1.2.2 数组深浅拷贝

```js
res.push([...path]); // path数组浅拷贝push入res中
res.push(path); // path数组深拷贝push入res中
```



## 2. 题型方法论

### 2.1 双指针-链表

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)、[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)、[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)、[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)、[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)：

####  [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```js
var mergeTwoLists = function(list1, list2) {
    // 遍历解
    let dummy = new ListNode(0);
    let p = dummy;
    while(list1 && list2){
        if(list1.val >= list2.val){
            p.next = list2;
            list2 = list2.next;
        }else{
            p.next = list1;
            list1 = list1.next;
        }
        p = p.next;
    }
    if(list1) p.next = list1;
    if(list2) p.next = list2;

    return dummy.next;
};
```

#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```js
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode(0);
    dummy.next = head; // 不要忘记dummy连上头节点
    let slow = dummy;
    let fast = dummy;

    for(let i = 0;i < n;i++){
        fast = fast.next;
    }
    while(fast.next){
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;

    return dummy.next;
};
```

练习：[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

#### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

```js
var getIntersectionNode = function (headA, headB) {
    if(!headA || !headB) return null;

    let pA = headA;
    let pB = headB;

    while(pA !== pB){
        pA = pA ? pA.next : headB;
        pB = pB ? pB.next : headA;
    }

    // 走完o(m+n)，一定有pA === pB；
    return pA; // 有交点，pA是交点；无交点，pA此时为null；
};
```

#### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```js
// 只需要判断是否有环
var hasCycle = function(head) {
    if(!head) return false;

    let slow = head;
    let fast = head.next; // 注意 必须快指针初始在前

    while(fast && fast.next){
        if(slow === fast) return true;
        slow = slow.next;
        fast = fast.next.next;
    }

    return false;
};
```

练习：[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```js
// 要求返回环入口节点
var detectCycle = function(head) {
    if(!head) return null;

    let slow = head;
    let fast = head; // 快慢指针同时走

    while(fast && fast.next){
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast){ // 此时slow,fast不一定在环入口
            let p = head;
            while(p !== slow){ // 找环入口
                p = p.next;
                slow = slow.next;
            }
            return p;
        }
    }

    return null;
};
```

### 2.2 双指针-数组

#### 2.2.1 快慢指针-原地修改

[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)、[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)、[27. 移除元素](https://leetcode.cn/problems/remove-element/)、[283. 移动零](https://leetcode.cn/problems/move-zeroes/)：

##### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```js
var removeDuplicates = function(nums) {
    if(nums.length === 0) return 0;
    
    let slow = 0;
    for(let fast = 0;fast < nums.length;fast++){
        if(nums[slow] !== nums[fast]){
            slow++;
            nums[slow] = nums[fast];
        }
    }
    // 不需要考虑数组中超出新长度后面的元素
    return slow + 1;
};
```

练习：[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)、[27. 移除元素](https://leetcode.cn/problems/remove-element/)、[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

#### 2.2.2 快慢指针-滑动窗口

##### 解题框架

```js
// 索引区间 [left, right) 是窗口
let left = 0, right = 0;

while (right < nums.size()) {
    // 增大窗口
    window.addLast(nums[right]);
  	// ...
    right++;
    
  	// 满足条件缩小窗口
    while (window needs shrink) {
        // 缩小窗口
        window.removeFirst(nums[left]);
      	// ...
        left++;
    }
}
```

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)、[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)、[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)、[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)：

##### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```js
var minWindow = function (s, t) {
    if(s.length < t.length) return "";

    const need = new Map();
    const window = new Map();

    for(let p of t){
        // 获取need哈希表中p字符的个数，如果个数为0，那么need.get(p)返回值为undefined；
        // undefined || 0 返回值为0；
        need.set(p , (need.get(p) || 0) + 1) 
    }

    let left = 0 , right = 0;
    let start = 0 , len = Infinity;
    let valid = 0;  // window中多少种字符已经满足了 need 的要求，注意是种类不是数量；


    while(right < s.length){
        let p = s[right];

        if(need.has(p)){
            window.set(p , (window.get(p) || 0) + 1);
            if(window.get(p) === need.get(p)) valid++;
        }

        right++;

        while(valid === need.size){
            let d = s[left];

            if(need.has(d)){
                window.set(d , window.get(d) - 1);
                if(window.get(d) < need.get(d)) valid--;
            }

            if(right - left < len){
                start = left;
                len = right - left;
            }

            left++;
        }
    }

    return len === Infinity ? "" : s.substring(start , start + len);
};
```

练习：[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)、[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)、[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

#### 2.2.3 左右指针-二分查找

...

#### 2.2.4 左右指针-n数之和

##### [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```js
var twoSum = function(numbers, target) {
    // 下标从 1 开始的整数数组 numbers：表示返回的下标必须是从 1 开始数的，但反问数组元素仍然从0开始？？？
    let left = 0;
    let right = numbers.length - 1;
    while(left < right){
        let sum = numbers[left] + numbers[right];
        if(sum > target){
            right--;
        }else if(sum < target){
            left++;
        }else{
            return [left + 1 , right + 1];
        }
    }
};
```

#### 2.2.5 左右指针-回文串判断

##### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

```js
var longestPalindrome = function (s) {
    // 优化版本：变量减少、相同逻辑模块化；
    let maxLen = 1;
    let maxStr = s[0];

    function centerExpand(left,right){
        while(left >= 0 && right < s.length && s[left] === s[right]){
            if(right - left + 1 > maxLen){
                maxLen = right - left + 1;
                maxStr = s.slice(left,right + 1);
            }
            left--;
            right++; 
        }
    }

    for(let i = 0;i < s.length;i++){
        let j = 1;
        centerExpand(i - j,i + j);
        j = 1;
        centerExpand(i - j,i + j - 1);
    }

    return maxStr;
};
```

### 2.3 递归/DFS

#### 2.3.1 岛屿问题-dfs模版

##### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```js
var numIslands = function (grid) {

    if(!grid || grid.length === 0) return 0; // grid为null || grid为空[]

    const rows = grid.length;
    const cols = grid[0].length;
    let count = 0;

    // 深度优先
    function dfs(i , j){
        if(i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === '0') return;

        grid[i][j] = '0';

        dfs(i + 1 , j);
        dfs(i - 1 , j);
        dfs(i , j + 1);
        dfs(i , j - 1);
    }

    for(let i = 0;i < rows;i++){
        for(let j = 0;j < cols;j++){
            if(grid[i][j] === '1'){
                dfs(i , j);
                count++;
            }
        }
    }

    return count;

};
```

练习：[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

#### 2.3.2 二叉树递归-遍历型

[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)、[112. 路径总和](https://leetcode.cn/problems/path-sum/)、[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)、[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

##### 解题框架

```js
function dfs(node, info, level) {
    // 1. base case
    if (!node) return null/0;

    // 2. 更新信息
    let newInfo = update(info, node);

    // 3. 叶子节点特殊处理
    if (!node.left && !node.right) {
        return handleLeaf(node, newInfo, level);
    }

    // 4. 递归左右子树
    let left = dfs(node.left, newInfo, level + 1);
    let right = dfs(node.right, newInfo, level + 1);

    // 5. 返回 / 记录结果
    return combine(left, right, node, newInfo, level);
}
```

题解：

```js
// 104. 二叉树的最大深度
var maxDepth = function(root){
  if(!root) return 0;
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
// 112. 路径总和
var hasPathSum = function(root, targetSum){
    if(!root) return false;
    if(!root.left && !root.right) return root.val === targetSum;

    let leftHasPath = hasPathSum(root.left, targetSum - root.val);
    let rightHasPath = hasPathSum(root.right, targetSum - root.val);

    return leftHasPath || rightHasPath;
}
// 129. 求根节点到叶节点数字之和
var sumNumbers = function(root) {
    function dfs(node, sum){
        if(!node) return 0;

        sum = sum * 10 + node.val;

        if(!node.left && !node.right) return sum;

        return dfs(node.left, sum) + dfs(node.right, sum);
    }

    return dfs(root, 0);
};
// 199. 二叉树的右视图
var rightSideView = function(root){
    const res = [];

    function func(node, i){
        if(!node) return;
        if(res[i] === undefined) res[i] = node.val;

        func(node.right, i + 1);
        func(node.left, i + 1);
    }

    func(root, 0);

    return res;
}
```

#### 2.3.3 二叉树递归-分治型：是否对称、相同、平衡

##### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```js
// 101. 对称二叉树
var isSymmetric = function (root) {
    if(!root) return true;

    function isMirror(t1, t2){
        if(!t1 && !t2) return true;
        if(!t1 || !t2) return false;
        if(t1.val !== t2.val) return false;

        return isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);
    }

    return isMirror(root.left, root.right);
};
```

练习：[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)、[100. 相同的树](https://leetcode.cn/problems/same-tree/)

#### 2.3.4 [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```js
// 105. 从前序与中序遍历序列构造二叉树
var buildTree = function(preorder, inorder) {

    const map = new Map();
    for(let i = 0;i < inorder.length;i++){
        map.set(inorder[i], i);
    }

    let preIndex = 0;

    function func(left, right){
        if(left > right) return null;

        let rootVal = preorder[preIndex++];
        let rootIndex = map.get(rootVal);

        let root = new TreeNode();
        root.val = rootVal;
        root.left = func(left, rootIndex - 1);
        root.right = func(rootIndex + 1, right);

        return root;
    }

    return func(0, inorder.length - 1);
};
```

练习：[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

DFS和BFS之一补充二叉树层序遍历，或者基础知识部分补充

### 2.4 BFS

### 2.5 动态规划

### 2.6 回溯

#### 2.6.1 不包含重复数字场景

解题框架：

```js
const res = [];
function backtrack(路径, 选择列表){
  if(满足结束条件){
    res.add(路径);
    return;
  }
  
  for(let 选择 of 选择列表){
    做选择;
    backtrack(路径, 选择列表);
    撤销选择;
  }
}
```

##### [46. 全排列](https://leetcode.cn/problems/permutations/)

```js
var permute = function (nums) {
    const res = [];

    function backtrack(path){
        if(path.length === nums.length){
            res.push([...path]); // 浅拷贝，而res.push(path)是深拷贝
            return;
        }

        for(let num of nums){
            if(path.includes(num)) continue;
            path.push(num);
            backtrack(path);
            path.pop(num);
        }
    }

    backtrack([]);

    return res;
};
```

练习：[93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)、[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)
