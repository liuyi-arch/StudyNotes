4.1 `npm i classnames -S`安装 classnames；

4.2 我们将登录页面的逻辑和注册页面的逻辑做到同一个页面中，通过一个 type 参数作为判断条件，判断当前状态是登录页面或是注册页面。对页面结构作如下改动（vscode粘贴到github中.md文件中会乱码，可以粘贴编辑器再格式化，代码结构更清晰）：

```jsx
...
import cx from 'classnames'
...

return (
    <div className={s.auth}>
        ...
        <div className={s.tab}>
            <span className={cx({ [s.active]: type == 'login' })} onClick={() => setType('login')}>登录</span>
            <span className={cx({ [s.active]: type == 'register' })} onClick={() => setType('register')}>注册</span>
        </div>
        ...
        <div className={s.form}>
            ...
            {
                type == 'register' ? <Cell icon={<CustomIcon type="mima" />}>
                    <Input
                        clearable
                        type="text"
                        placeholder="请输入验证码"
                        value={verify}
                        onChange={(value) => setVerify(value)}
                    />
                    {/* Cell组件只允许放置行内元素，若放置块级元素会破坏原有原有Cell布局，因此需要给div加上display: inline-block;样式 */}
                    <div
                        className={s.captchaWrapper}
                        onClick={() => loadCaptchaEnginge(4)}
                    >
                        <LoadCanvasTemplateNoReload />
                    </div>
                </Cell> : null
            }
        </div>
            {
                type == 'register' ? <div className={s.agree}>
                    <Checkbox />
                    <label className="text-light">阅读并同意<a>《掘掘手札条款》</a></label>
                </div> : null
            }
            <Button onClick={onSubmit} block theme="primary">
                {type == 'login' ? '登录' : '注册'}
            </Button>
        </div>
    </div>
);
```

4.3 点击触发的 onSubmit 事件同样需要通过 type 判断是登录还是注册，我们作如下改动：

```jsx
const Login = () => {
    const [type, setType] = useState('login'); // 登录注册类型
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [verify, setVerify] = useState('');

    useEffect(() => {
        if (type === 'register') {
            loadCaptchaEnginge(4);
        }
    }, [type]);
    

    const onSubmit = async () => {
        if (!username) {
            Toast.show('请输入账号')
            return
        }
        if (!password) {
            Toast.show('请输入密码')
            return
        }
        try {
            // 判断是否是登录状态
            if (type == 'login') {
                // 执行登录接口，获取 token
                const { data } = await post('/api/user/login', {
                    username,
                    password
                });
                Toast.show('登录成功');
                // 将 token 写入 localStorage
                localStorage.setItem('token', data.token);
            } else {
                if (!verify) {
                    Toast.show('请输入验证码')
                    return
                };
                if (!validateCaptcha(verify)) {
                    Toast.show('验证码错误')
                    loadCaptchaEnginge(4); // 验证失败时重新加载验证码
                    return;
                }
                const { data } = await post('/api/user/register', {
                    username,
                    password
                });
                Toast.show('注册成功');
                // 注册成功，自动将 tab 切换到 login 状态
                setType('login');
            }
        } catch (error) {
            Toast.show('系统错误');
        }
    };
};
```

4.4 重启项目，验证登录接口是否成功，如果成功则会返回 token 信息。我们将token信息存储在本地的 localStorage 中，如下图所示：


![img](https://cdn.nlark.com/yuque/0/2022/png/338969/1666060652881-18154484-c146-4d8b-b858-81537ba0afb3.png)


我们拿到的 token 是有时效性的，后台设置的是 24 小时的时效，如果过期，请求其他接口时，就会报错，从而通过逻辑判断重新回到登录页面。下一章节，详细分析这部分内容。

