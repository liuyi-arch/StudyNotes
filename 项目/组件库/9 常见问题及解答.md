## 组件库-常见问题及解答

- 为什么选择 Monorepo 架构来管理组件库？相比多仓库方式有哪些优劣？✅

  优势：

  - 所有包在一个仓库中，方便管理依赖，因为一个包可以直接依赖另一个包的本地源码；
  - 工具配置如ESLint、TS、Vite可以放在根目录共享；通用工具函数共享；

  劣势：

  - CI/CD集成配置复杂、需要熟悉Monorepo管理工具比如pnpm workspace；

- 你是如何实现组件的按需引入和全量引入的？用了哪些工具或技术？✅

  全量引入：

  - 在组件库的主入口文件（如 src/main.ts）统一导出所有组件；
  - package.json 的 module、exports 字段指向打包后的主入口文件 dist/main.js；

  按需引入：

  - 在 package.json 的 exports 字段中为每个组件配置子路径导出；

  - 另外，需要为每个组件生成独立入口，也就是在vite.config.ts 的 rollupOptions.input字段配置，具体细节可以参考rollups input官方示例代码和文档说明；https://rollupjs.org/configuration-options/#input；

- 组件库是如何分类和组织的？你怎么保证结构清晰且便于扩展？✅

  - 每个组件单独建立一个文件夹，每个组件文件夹包含组件主要实现文件、私有样式文件、storybook文档以及单元测试文件，实现高内聚、低耦合；

  - 也可以按组件类型再进一步细分为通用基础组件、数据录入组件等；

- 你在实现比如 Upload 或 AutoComplete 这类复杂组件时，遇到过哪些难点？是怎么解决的？✅

  - 状态管理：每个文件都有自己独立的状态，比如ready、uploading、success、error等，管理复杂；可以为每个文件创建一个包含其所有状态的对象，比如UpLoad组件的UploadFile接口，使用一个数组fileList统一管理，通过uid找到特定文件；
  - 并发上传和取消上传：
    - 对于并发上传，可以维护一个上传队列，并限制上传数量；
    - 对于取消上传，可以使用XMLHttpRequest提供的abort方法，在onRemove回调被触发时调用它，并清理相关状态；

- 如何在 Storybook 中实现组件的交互演示和属性说明？有没有做二次封装或自定义插件？✅

  - 属性说明：通过在每个组件的 stories 文件中使用 argTypes，使Storybook 会自动生成属性表；见官方文档argTypes示例：https://storybook.js.org/docs/api/argtypes；

- 交互演示：在 stories 文件中通过不同的 story 展示组件的各种交互状态；

  - 自定义全局装饰器（如 ThemeProvider、国际化等）：在 .storybook/preview.ts 中配置；

- Preview 插件的设计原理是什么？它是怎么做到实时预览和代码高亮的？✅

  - 实时预览：指的是在 Storybook 或组件文档中，可以实时修改 props 或代码片段，能够看到组件的实际渲染效果；

  - 代码高亮：指的是在文档或预览区展示组件源码时，代码以高亮格式显示，提升可读性。

  - 具体实现：在 MyButton.stories.tsx 文件中，集成了第三方库 react-live，使用 LiveProvider、LiveEditor、LivePreview 组件，其中LiveProvider有两个重要的属性code和scope，将MyButton 组件的代码字符串作为 code 传入，组件本身则通过scope传递；详细见官方文档https://nearform.com/open-source/react-live/docs/usage；
  - 其他：
    - 也可以使用Storybook 内置的热模块替换 (HMR) 提供实时预览功能；即当组件代码或属性发生变化时，预览区域会自动更新。
    - Storybook 的文档功能（docs）支持代码高亮，通常通过 `<Source>` 文档块或 `docs` 参数在 故事文件中实现。底层依赖 `react-syntax-highlighter` 库。

- highlight.js 是怎么集成到文档展示中的？你有没有对高亮主题或样式做过定制？✅

  - 在 src/utils/CodeHighlight/index.tsx 中封装了一个 CodeHighlight 组件；

  - 组件挂载后调用 highlight.js的highlightElement() ，接受code、language等参数；

  - 然后在 MyButton.stories.tsx 中引入 CodeHighlight 组件，传递MyButton的code和language参数，实现代码高亮；

  - 可以使用css变量来实现动态切换主题；

- ESLint、Prettier、Husky、lint-staged 是如何集成在 CI 流程中的？这些工具分别解决了哪些问题？✅

  本地开发钩子集成：

  - git add将文件添加到暂存区；
  - 执行git commit命令，git钩子管理器husky出发pre-commit钩子，执行钩子中脚本pnpm exec lint-staged，启动lint-staged工具对暂存文件进行检查和修复；
  - lint-staged会读取package.json中lint-staged字段的配置，对配置中tsx文件执行eslint --fix操作，对样式文件执行style lint --fix操作，对.md、json执行prettier --write操作；

  CI集成：

  - 推送到main分支或创建 PR触发；
  - 执行.github/workflows/xx.yml文件中配置；
  - 依次安装依赖 (pnpm install --frozen-lockfile)、执行ESLint 检查、Stylelint、Prettier 格式检查、运行测试ppm test、构建库pnpm build；

  各工具解决的问题：

  - **ESLint**：检查代码质量和风格一致性。比如未使用变量、双引号变单引号等；
  - **Prettier**：检查代码格式。比如缩进、分号等；
  - **Husky**：**Git 钩子管理器**；
  - **Lint-staged**：对在暂存区的文件进行检查；

- Vetest 单元测试中是如何设计用例的？主要测试哪些场景？有没有遇到过模拟异步交互的问题？✅

  如何设计测试用例：

  - 测试用例采取业界广泛使用的AAA（Arrange-Act-Assert）模式；
  - 使用describe块将所有测试用例包装，it块定义具体的某个测试用例；
  - Arrange部分：准备测试所需的环境和数据；使用render()渲染被测试的组件，使用vi.fn()创建mock function；
  - Act部分：用来模拟用户操作或触发事件；使用fireEvent模拟用户交互，比如fireEvent.click模拟点击、fireEvent.change模拟文件选择、fireEvent.drop模拟拖拽；
  - Assert部分：验证测试结果是否符合预期；使用screen对象查询DOM元素，比如sreen.getByText、screen.getByRole；使用expect搭配匹配器进行断言，比如toBeDisabled()、toHaveBeenCalledTimes(1)；

  主要测试场景：

  - 基础渲染测试：测试组件是否能成功渲染到DOM中；
  - Props渲染测试：测试组件传入的props是否正确显示，比如label参数是否被正确渲染；
  - 状态与行为测试：测试组件在不同props或state下的行为是否符合预期，比如disabled参数为true时，按钮是否真的处于禁用状态；
  - 用户交互测试：测试事件是否被正确调用；
  - 异步流程测试：测试需要时间完成的异步操作，比如文件上传后，UI是否更新为上传成功的状态；

  模拟异步交互：

  - 比如myUpLoad组件中封装MockXML类实现真实的XMLHttpRequest请求，其中send方法使用setTimeout模拟网络请求的耗时；

- 组件的 props 类型定义是如何做的？有没有用到泛型或联合类型？✅

  - 组件的类型定义使用了typescript的一些高级特性，比如MyButton的props接口通过extends React.ComponentProps<'button'>继承原生HTML button元素的所有属性，除此之外，还可以定义组件自身的props；

  - 联合类型：MyButton的size prop使用了联合类型来限制可接受的值；

    ```ts
    size?: 'small' | 'medium' | 'large'
    ```

  - 泛型：暂时没有使用，但是在MyUpLoad中上传成功后onSuccess回调返回的数据结构不稳定，可以使用泛型来约束返回数据和回调函数的类型；比如select组件，select<T>，T表示options数组中所有可能的类型；

- 如何保证组件在多种场景下的可复用性和扩展性？有没有做 slots、render props 或 context 的封装？✅

  扩展性：

  - 使用Props透传，通过在接口定义时继承原生属性，并在组件内部使用...prps将其余属性透传给底层HTML元素；
  - 钩子方法：比如MyButton中beforeUpLoad prop允许用户在上传前介入，可以执行自定义逻辑，比如校验文件大小或类型；

- 组件的样式是怎么写的？用了哪种 CSS 方案（如 CSS Modules、Tailwind、cssinjs）？为什么选它？✅

  - 使用css Modules方案，通过clix工具库组合class名称，比如clsx(styles.button, { [styles['button--primary']]: primary })；
  - css Modules会为每个class生成一个hash值，能够隔离作用域，避免css全局命名冲突；但全局样式管理困难；

  其他css方案：

  - Sass/Less：结构化，可维护性好；
  - Tailwind：提供大量工具类，适合快速开发、允许通过修改配置文件实现高度定制颜色、字体等；类名冗长，不语义化；
  - cssinjs：组件化，支持主题化，通过上下文或主体提供器共享样式实现；性能问题；

- 你如何在 Storybook 中同步组件的更新（热更新）？有没有解决过 story 内容不同步或渲染异常的问题？✅

  - storybook内置对热更新的支持，它主要依赖底层构建工具vite；
  - story渲染问题解决：
    - 缓存问题：有时构建工具的缓存会导致热更新不生效；解决办法是删除node_modules/.vite目录，重启服务；
    - 状态管理问题：热更新只会替换组件代码，不会重置状态；解决办法是在story文件中使用useEffect或storybook的loaders初始化和重置状态；
    - 样式叠加：可以考虑是否是全局样式影响；

- 组件库是否做了版本管理和发布？是怎么发布到 npm 的？如何处理依赖更新问题？❌

- 你有没有设计“主题化”或“国际化”功能？如果需要支持换肤或多语言，该怎么扩展组件架构？❌

- 项目开发过程中，有没有团队协作？你是如何制定组件规范和开发流程的？✅

  - 项目搭建之初，集成ESLint、Prettier等工具、pre-commit等钩子，确保编码规范；
  - 独立feature分支开发、pull request代码审查通过后才能合并等流程；

- 你怎么看目前市面上的开源组件库（如 Ant Design、MUI），你们组件库的定位和目标是什么？✅

- 使用 pnpm workspace 时，是否遇到过依赖冲突或包引用异常？是怎么处理的？✅

  - 对于某个不规范的库，可能依赖某个包但是没有声明；在package.json中显示安装缺失依赖；
  - 不同包依赖同一个库的不同版本；可以将这个库的两个版本安装到虚拟store中，然后通过软链接指向各自的node_modules；

- 你是否做过组件性能优化，比如渲染优化、虚拟滚动、懒加载等？✅

  - 渲染优化：
    - 可以考虑使用React.memo包裹纯函数式组件，避免父组件和子组件的重复渲染；
    - 使用useCallback缓存传递给子组件的回调函数；使用useMemo缓存计算成本高的对象或数组；
  - 虚拟滚动：对于需要渲染大量列表数据的组件，比如Select下拉菜单、Table等，可以通过react-window或react-virtualized等库实现只渲染视口内的列表项；
  - 懒加载：可以使用React.lazy或Suspense对非首屏的组件进行懒加载；可以使用Intersection Observer API实现图片进入视口再加载；

- 你会如何衡量一个组件是否“设计得好”？有哪些判断标准或经验？✅

  高内聚、低耦合、可扩展、完备文档和示例；
