# 组件库项目

- 1. 为什么选择 Monorepo 架构来管理组件库？相比多仓库方式有哪些优劣？

  选择 **Monorepo 架构** 来管理组件库，主要有三个原因：

  - 第一，**依赖管理更方便**。所有包在一个仓库，仓库内部相互依赖的包，可以直接本地联动开发，不需要频繁发版调试，效率更高。
  - 第二，**工程化和规范统一**。在仓库根目录共用 ESLint、Prettier等配置，避免多仓库重复配置，保证风格和质量一致。
  - 第三，便于团队协作。

  劣势：

  - 仓库体积更大；CI/CD集成配置复杂；

- 2. 你是如何实现组件的按需引入和全量引入的？用了哪些工具或技术？

  全量引入：

  - 在组件库的主入口文件（如 src/main.ts）统一导出所有组件；
  - package.json 的 module、exports 字段指向打包后的主入口文件 dist/main.js；

  按需引入：

  - 在 package.json 的 exports 字段中为每个组件配置子路径导出；

  - 另外，需要为每个组件生成独立入口，也就是在vite.config.ts 的 rollupOptions.input字段配置，具体细节可以参考rollups input官方示例代码和文档说明；https://rollupjs.org/configuration-options/#input；

- 3. 组件库是如何分类和组织的？你怎么保证结构清晰且便于扩展？

  - 每个组件单独建立一个文件夹，每个组件文件夹包含组件主要实现文件、私有样式文件、storybook文档以及单元测试文件，实现高内聚、低耦合；

  - 也可以按组件类型再进一步细分为通用基础组件、数据录入组件等；

- 4. 你在实现比如 Upload 或 AutoComplete 这类复杂组件时，遇到过哪些难点？是怎么解决的？

  - 每个文件都有自己独立的状态，比如ready、uploading、success、error等，管理复杂；

    - 为每个文件创建一个包含其所有状态的对象UploadFile，使用一个数组fileList统一管理，通过uid找到特定文件；

      ```tsx
      export interface UploadFile {
          uid: string;
          name: string;
          status?: 'ready' | 'uploading' | 'success' | 'error';
          percent?: number;
          raw: File;
          response?: any;
          error?: any;
      }
      ```

  - 并发上传和取消上传场景处理：

    - 对于并发上传，可以维护一个上传队列，并限制上传数量；
    - 对于取消上传，可以使用XMLHttpRequest提供的abort方法，在onRemove回调被触发时调用它，然后清理相关状态；

- 5. 如何在 Storybook 中实现组件的交互演示和属性说明？有没有做二次封装或自定义插件？

  - 属性说明：通过在每个组件的 stories 文件中使用 storybook的argTypes API，自动生成属性表；见官方文档argTypes示例：https://storybook.js.org/docs/api/argtypes；

  - 交互演示：在 stories 文件中通过不同的 story 展示组件的各种交互状态，Button large、small等；

  - ~~自定义全局装饰器（如 ThemeProvider、国际化等）：在 .storybook/preview.ts 中配置；~~

- 6. Preview 插件的设计原理是什么？它是怎么做到实时预览和代码高亮的？

  - 实时预览：指的是在 Storybook 或组件文档中，可以实时修改 props 或代码片段，能够看到组件的实际渲染效果；

  - 代码高亮：指的是在文档或预览区展示组件源码时，代码以高亮格式显示，提升可读性。

  - 具体实现：在 MyButton.stories.tsx 文件中，集成了**第三方库 react-live**，使用 **LiveProvider、LiveEditor、LivePreview 组件**，其中LiveProvider有两个重要的属性**code和scope，将MyButton 组件的代码字符串作为 code 传入，组件本身则通过scope传递**；详细见官方文档https://nearform.com/open-source/react-live/docs/usage；

    > - 也可以使用**Storybook 内置的热模块替换 (HMR)** 提供实时预览功能；即当组件代码或属性发生变化时，预览区域会自动更新。
    >
    > - Storybook 的文档功能（docs）支持代码高亮，通常通过 **`<Source>` 文档块**或 `docs` 参数在 故事文件中实现。底层依赖 `react-syntax-highlighter` 库。

- 7. highlight.js 是怎么集成到文档展示中的？你有没有对高亮主题或样式做过定制？

  - 在 src/utils/CodeHighlight/index.tsx 中封装了一个 **CodeHighlight 组件**；

  - 组件挂载后调用 highlight.js的**highlightElement() ，接受code、language等参数**；

  - 然后在 MyButton.stories.tsx 中引入 CodeHighlight 组件，传递MyButton的code和language参数，实现代码高亮；

    > 可以使用css变量来实现动态切换主题；

- 8. ESLint、Prettier、Husky、lint-staged 是如何集成在 CI 流程中的？这些工具分别解决了哪些问题？

  本地开发钩子集成：

  - git add将文件添加到暂存区；
  - 执行git commit命令，git钩子管理器husky触发pre-commit钩子，**执行钩子中脚本pnpm exec lint-staged，启动lint-staged工具对暂存文件进行检查和修复**；
  - **lint-staged会读取package.json中lint-staged字段的配置**，对配置中tsx文件执行eslint --fix操作，对样式文件执行style lint --fix操作，对.md、json执行prettier --write操作；

  CI集成：

  - 推送到main分支或创建 PR触发；
  - 执行**.github/workflows/xx.yml**文件中配置；
  - 依次安装依赖 (pnpm install --frozen-lockfile)、执行ESLint 检查、Stylelint、Prettier 格式检查、运行测试pnpm test、构建库pnpm build；

  各工具解决的问题：

  - **ESLint**：检查**代码质量**和风格一致性。比如未使用变量、双引号变单引号等；
  - **Prettier**：检查**代码格式**。比如缩进、分号等；
  - **Husky**：**Git 钩子管理器**；
  - **Lint-staged**：对在**暂存区的文件进行检查**；

- 9. Vetest 单元测试中是如何设计用例的？主要测试哪些场景？有没有遇到过模拟异步交互的问题？

  如何设计测试用例：

  - 测试用例采取业界广泛使用的**AAA（Arrange-Act-Assert）模式**；
  - 使用**describe块将所有测试用例包装，it块定义具体的某个测试用例**；
  - Arrange部分：准备测试所需的**环境和数据**；使用render()渲染被测试的组件，使用**vi.fn()创建mock function**；
  - Act部分：用来**模拟用户操作或触发事**件；使用**fireEvent模拟用户交互**，比如fireEvent.click模拟点击、fireEvent.change模拟文件选择、fireEvent.drop模拟拖拽；
  - Assert部分：**验证测试结果**是否符合预期；使用screen对象查询DOM元素，比如sreen.getByText、screen.getByRole；使用**expect搭配匹配器进行断言**，比如toBeDisabled()、toHaveBeenCalledTimes(1)；

  主要测试场景：

  - 基础渲染测试：测试组件**是否能成功渲染到DOM中**；
  - Props渲染测试：测试组件**传入的props是否正确显示**，比如label参数是否被正确渲染；
  - 状态与行为测试：测试组件在**不同props或state下的行为是否符合预期**，比如disabled参数为true时，按钮是否真的处于禁用状态；
  - 用户交互测试：测试**事件是否被正确调用**；
  - 异步流程测试：测试需要时间完成的**异步操作**，比如文件上传后，UI是否更新为上传成功的状态；

  模拟异步交互：

  - 比如myUpLoad组件中**封装MockXML类实现真实的XMLHttpRequest请求**，其中**send方法使用setTimeout模拟网络请求的耗时**；

- 10. 组件的 props 类型定义是如何做的？有没有用到泛型或联合类型？

  - 如何做：MyButton的props接口通过**extends React.ComponentProps<'button'>**继承原生HTML button元素的所有属性 + 定义组件自身的props；

  - 联合类型：MyButton的size prop使用了**联合类型来限制可接受的值**；

    ```ts
    size?: 'small' | 'medium' | 'large'
    ```

  - 泛型：暂时没有使用，但是在MyUpLoad中上传成功后onSuccess回调返回的数据结构不稳定，可以使用**泛型来约束返回数据和回调函数的类型**；比如select组件，select<T>，T表示options数组中所有可能的类型；

- 11. 如何保证组件在多种场景下的可复用性和扩展性？有没有做 slots、render props 或 context 的封装？

  扩展性：

  - 使用**Props透传**，通过在**接口定义时继承原生属性**，并在**组件内部使用...props将其余属性透传给底层HTML元素**；

    > 钩子方法：比如MyButton中beforeUpLoad prop允许用户在上传前介入，可以执行自定义逻辑，比如校验文件大小或类型；

- 12. 组件的样式是怎么写的？用了哪种 CSS 方案（如 CSS Modules、Tailwind、cssinjs）？为什么选它？

  - 使用**CSS Modules方案，通过clix工具库组合class名称**，比如clsx(styles.button, { [styles['button--primary']]: primary })；
  - **CSS Modules会为每个class生成一个hash值，能够隔离作用域，避免css全局命名冲突**；但全局样式管理困难；

  > 其他css方案：
  >
  > - Sass/Less：结构化，可维护性好；
  > - Tailwind：提供大量工具类，适合快速开发、允许通过修改配置文件实现高度定制颜色、字体等；类名冗长，不语义化；
  > - cssinjs：组件化，支持主题化，通过上下文或主体提供器共享样式实现；性能问题；

- 13. 你如何在 Storybook 中同步组件的更新（热更新）？有没有解决过 story 内容不同步或渲染异常的问题？

  - storybook内置对热更新的支持，它主要依赖底层构建工具vite；
  - story渲染问题解决：
    - 缓存问题：有时**构建工具的缓存会导致热更新不生效**；解决办法是**删除node_modules/.vite目录，重启服务**；
    - 状态管理问题：热更新只会替换组件代码，不会重置状态；解决办法是在story文件中使用useEffect或**storybook的loaders初始化和重置状态**；
    - 样式叠加：可以考虑是否是全局样式影响；

- 14. 组件库是否做了版本管理和发布？是怎么发布到 npm 的？如何处理依赖更新问题？

- 15. 你有没有设计“主题化”或“国际化”功能？如果需要支持换肤或多语言，该怎么扩展组件架构？

- 16. 项目开发过程中，有没有团队协作？你是如何制定组件规范和开发流程的？

  - 项目搭建之初，集成ESLint、Prettier等工具、pre-commit等钩子，确保编码规范；
  - 独立feature分支开发、pull request代码审查通过后才能合并等流程；

- 17. 你怎么看目前市面上的开源组件库（如 Ant Design、MUI），你们组件库的定位和目标是什么？

- 18. 使用 pnpm workspace 时，是否遇到过依赖冲突或包引用异常？是怎么处理的？

  - 对于某个不规范的库，可能依赖某个包但是没有声明；在package.json中显示安装缺失依赖；
  - 不同包依赖同一个库的不同版本；可以将这个**库的两个版本安装到虚拟store**中，然后**通过软链接指向各自的node_modules**；

- 19. 你是否做过组件性能优化，比如渲染优化、虚拟滚动、懒加载等？

  - 渲染优化：
    - 可以考虑**使用React.memo包裹纯函数式组件，避免父组件和子组件的重复渲染**；
    - 使用**useCallback缓存传递给子组件的回调函数**；使用**useMemo缓存计算成本高的对象或数组**；
  - 虚拟滚动：对于需要渲染大量列表数据的组件，比如Select下拉菜单、Table等，可以通过**react-window或react-virtualized**等库实现只渲染视口内的列表项；
  - 懒加载：可以使用**React.lazy或Suspense对非首屏**的组件进行懒加载；可以使用**Intersection Observer API实现图片进入视口再加载**；

- 20. 你会如何衡量一个组件是否“设计得好”？有哪些判断标准或经验？

  高内聚、低耦合、可扩展、完备文档和示例；
